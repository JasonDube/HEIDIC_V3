# Resource System Implementation Plan

## Philosophy

**Speed of iteration + Engine performance** - Zero-boilerplate resource loading that just works.

---

## Resource Types

### Phase 1: Core Resources (Start Here)

#### 1. **Textures/Images** 
```heidic
// Production assets (GPU-ready, zero-copy)
resource Texture = "textures/brick.dds";        // BC7 compressed
resource Texture = "textures/normal.ktx2";      // BC5 compressed
resource Texture = "textures/emissive.dds";     // R8 compressed

// Source/editor assets (human-readable, converted at build time)
resource Texture = "textures/source/cockpit_diffuse.png";  // Auto-converts → .dds
```

**Supported Formats (Priority Order):**

**Tier 1: Production (GPU-Ready, Zero-Copy) - ⚡ USE THESE**
- **DDS (BC7/BC5/R8)** - 0.8-2ms load, ~1-2MB GPU memory
  - BC7: RGB/RGBA (albedo, diffuse)
  - BC5: RG (normal maps)
  - R8: Grayscale (roughness, metalness, emissive)
- **KTX2 (BC7/ASTC)** - 0.8-2ms load, ~1-2MB GPU memory
  - Cross-platform (Vulkan standard)
  - Better than DDS for multi-platform

**Tier 2: Source/Editor (Convert at Build Time)**
- **PNG** - Lossless, human-editable, LLM-readable
  - Auto-converts to DDS/KTX2 during build
  - Keep source PNGs, ship with DDS
- **TGA** - Legacy support if needed

**Never Use:**
- ❌ BMP (40-80ms load, massive memory waste)
- ❌ PNG at runtime (18-35ms load, 12-16MB uncompressed → terrible)

**Performance Comparison:**
- DDS BC7: **1.1ms** load, **1-2MB** GPU memory
- PNG: **28-42ms** load, **12-16MB** GPU memory
- **25-40× faster**, **8-12× less memory** with DDS!

**Generated Code:**
- **DDS/KTX2**: Direct memory-mapped load → GPU (zero-copy, instant)
- **PNG**: Load → decompress → convert → upload (slow, but auto-converts during build)
- Creates `VkImage`, `VkImageView`, `VkSampler` automatically
- Handles mipmaps (from DDS/KTX2)
- Hot-reload support (reloads on file change)

---

#### 2. **Meshes/Models**
```heidic
resource Mesh = "models/cube.obj";
resource Mesh = "models/sponza.gltf";
```

**Supported Formats (Initial):**
- **OBJ** - Simple, easy to parse, good for testing
- **glTF 2.0** - Industry standard, supports materials, animations

**Generated Code:**
- Parses OBJ/glTF file
- Creates vertex/index buffers
- Uploads to GPU automatically
- Handles multiple meshes (if model has sub-meshes)
- Material references (textures, etc.)

---

#### 3. **Shaders** (Already partially supported, but wrap better)
```heidic
resource Shader = "shaders/pbr.vert";  // References existing @hot shader
resource Shader = "shaders/pbr.frag";
```

**Note:** We already have `@hot shader` declarations. Resources just wrap them in a clean API.

---

### Phase 2: Extended Resources

#### 4. **Audio** ✅ **IMPLEMENTED**
```heidic
resource JumpSound: Sound = "audio/jump.wav";
resource BackgroundMusic: Music = "audio/bgm.ogg";
```

**Supported Formats:**
- **WAV** - Uncompressed audio (good for short sound effects)
- **OGG** - Compressed audio (good for background music)
- **MP3** - Compressed audio (also supported)

**Generated Code:**
- Both `Sound` and `Music` map to `AudioResource` class
- Automatically detects format from file extension
- Loads audio data into memory (WAV) or sets up streaming (OGG)
- Hot-reload support (reloads on file change)
- Uses SDL3 audio API (if available)

**Implementation:**
- `stdlib/audio_resource.h` - AudioResource class
- Codegen updated to support `Sound` and `Music` resource types

#### 5. **Fonts** (Future)
```heidic
resource Font = "fonts/arial.ttf";
```

---

## Implementation Strategy

### Step 1: Texture Loading (Week 1)

**Why First:**
- Simpler than meshes
- Good foundation for other resources
- Immediate visual impact
- **MASSIVE performance win** with DDS/KTX2 (25-40× faster!)

**Dependencies:**
- **DDS/KTX2 loader** (vulkan-ktx or custom DDS parser)
- stb_image (for PNG source files, converts at build time)
- Vulkan image creation (already have helpers)

**Priority: DDS First!**
- Start with DDS support (Windows-friendly, widely used)
- Then add KTX2 (cross-platform standard)
- PNG support for source files (auto-converts during build)

**Syntax:**
```heidic
resource Texture = "textures/brick.png";
```

**Generated Code:**
```cpp
// Auto-generated by HEIDIC compiler
class TextureResource {
public:
    VkImage image;
    VkImageView imageView;
    VkSampler sampler;
    VkDeviceMemory memory;
    uint32_t width, height;
    VkFormat format;
    
    TextureResource(const std::string& path) {
        if (path.ends_with(".dds") || path.ends_with(".ktx2")) {
            // FAST PATH: GPU-ready compressed texture
            load_compressed_texture(path);  // 0.8-2ms, zero-copy
        } else if (path.ends_with(".png")) {
            // SLOW PATH: Source file (should be pre-converted)
            // For development only - warns in debug mode
            load_png_and_convert(path);  // 18-35ms, decompress first
        }
        
        // Create Vulkan image/view/sampler
        // DDS/KTX2: Direct upload (already compressed)
        // PNG: Decompress → convert → upload
    }
    
    void load_compressed_texture(const std::string& path) {
        // Memory-map DDS/KTX2 file
        // Read header (format, width, height, mipmaps)
        // Allocate GPU memory
        // Copy compressed data directly to GPU (zero-copy where possible)
        // Create image view & sampler
    }
    
    ~TextureResource() {
        // RAII cleanup
        vkDestroyImageView(...);
        vkDestroyImage(...);
        vkFreeMemory(...);
        vkDestroySampler(...);
    }
};

// Global instance (auto-initialized)
TextureResource g_texture_brick("textures/brick.dds");  // Fast!
```

---

### Step 2: OBJ Mesh Loading (Week 1-2)

**Why OBJ First:**
- Simple ASCII format (easy to parse)
- No dependencies (we write parser)
- Fast to implement
- Good for testing resource system

**Syntax:**
```heidic
resource Mesh = "models/cube.obj";
```

**OBJ Parser Implementation:**
```cpp
// stdlib/obj_loader.h (new file)
struct MeshData {
    std::vector<float> positions;  // Vec3 positions
    std::vector<float> normals;    // Vec3 normals
    std::vector<float> texcoords;  // Vec2 UVs
    std::vector<uint32_t> indices; // Index buffer
};

MeshData load_obj(const std::string& path);
```

**Features:**
- Parse `v` (vertices)
- Parse `vn` (normals)
- Parse `vt` (texture coordinates)
- Parse `f` (faces) - handle different formats:
  - `f 1 2 3` (position only)
  - `f 1/1 2/2 3/3` (position + UV)
  - `f 1/1/1 2/2/2 3/3/3` (position + UV + normal)

**Generated Code:**
```cpp
class MeshResource {
public:
    VkBuffer vertexBuffer;
    VkBuffer indexBuffer;
    VkDeviceMemory vertexBufferMemory;
    VkDeviceMemory indexBufferMemory;
    uint32_t indexCount;
    
    MeshResource(const std::string& path) {
        MeshData data = load_obj(path);
        // Create vertex/index buffers
        // Upload to GPU
    }
};

MeshResource g_mesh_cube("models/cube.obj");
```

---

### Step 3: glTF Loading (Week 2)

**Why glTF:**
- Industry standard
- Supports materials, textures, animations
- Better than OBJ for complex models

**Dependencies:**
- tinygltf (lightweight glTF loader)
- OR write our own parser (if we want zero dependencies)

**Syntax:**
```heidic
resource Mesh = "models/sponza.gltf";
```

**Features:**
- Multiple meshes per file
- Materials with texture references
- Transform hierarchies (for later)
- Animations (for later)

---

### Step 4: Custom .hdm (HEIDIC Model) Format (Week 3+)

**Why Custom Format:**
- **Maximum performance** - Binary, cache-friendly
- **Fast loading** - No parsing, direct memory map
- **EDEN-optimized** - Matches our SOA component layout
- **Smaller size** - Compressed, efficient encoding

**Design Goals:**
- Load in < 1ms for simple meshes
- Memory-mapped file I/O
- Compatible with SOA layout (for CUDA/OptiX later)
- Include material info
- Support LOD levels

**Syntax:**
```heidic
resource Mesh = "models/sponza.hdm";  // Custom optimized format
```

**Format Structure:**
```
[.hdm file header]
- Magic number: "HDM1"
- Version: uint32
- Mesh count: uint32
- Offset table: [offsets to each mesh]

[Per-mesh data]
- Vertex count: uint32
- Index count: uint32
- Positions: [Vec3 * vertex_count] (flat array)
- Normals: [Vec3 * vertex_count]
- UVs: [Vec2 * vertex_count]
- Indices: [uint32 * index_count]
- Material ID: uint32
- Bounding box: [min: Vec3, max: Vec3]
```

**Tooling:**
- **heidic-convert** command-line tool:
  ```bash
  heidic-convert sponza.obj sponza.hdm
  heidic-convert sponza.gltf sponza.hdm
  ```
- Converts OBJ/glTF → .hdm at build time
- Can be integrated into H_SCRIBE build process

**When to Add:**
- **After** OBJ/glTF loading works
- **After** we have a real game/test project using meshes
- **When** we need maximum performance
- **Before** CUDA/OptiX (SOA compatibility is critical)

---

## Resource System Architecture

### Compile-Time vs Runtime Loading

**Textures:**
- Option 1: Compile-time embedding (large binary sizes)
- Option 2: Runtime loading with hot-reload (preferred)
- **Decision:** Runtime loading with CONTINUUM hot-reload

**Meshes:**
- OBJ/glTF: Runtime loading (need parsing)
- .hdm: Could be compile-time embedded (small, fast)
- **Decision:** Runtime loading for all formats initially

### Resource Handle Wrapper

```cpp
// stdlib/resource.h (new file)
template<typename T>
class Resource {
private:
    std::unique_ptr<T> data;
    std::string path;
    std::time_t lastModified;
    
public:
    Resource(const std::string& path) : path(path) {
        load();
        register_hot_reload();  // CONTINUUM integration
    }
    
    T* get() { return data.get(); }
    T& operator*() { return *data; }
    T* operator->() { return data.get(); }
    
    void reload() {
        // Hot-reload: reload file if changed
        load();
    }
};
```

### CONTINUUM Integration

**Hot-Reload Support:**
```cpp
// Resources automatically register with CONTINUUM
void register_resource_hot_reload(const std::string& path, ResourceBase* resource) {
    // Register file watcher
    // On file change, call resource->reload()
}
```

**Usage:**
```heidic
resource Texture = "textures/brick.png";

// File changes automatically trigger reload
// Texture updates in-game without restart!
```

---

## Codegen Implementation

### HEIDIC Parser Changes

**New Token:**
```rust
// src/lexer.rs
Token::Resource  // New token for `resource` keyword
```

**New AST Node:**
```rust
// src/ast.rs
pub enum Item {
    // ... existing items
    Resource {
        name: String,
        resource_type: Type,
        path: String,
    },
}
```

**Parser Rule:**
```rust
// src/parser.rs
fn parse_resource(&mut self) -> Result<Item> {
    self.expect(Token::Resource)?;
    let name = self.expect_ident()?;
    self.expect(Token::Colon)?;
    let resource_type = self.parse_type()?;
    self.expect(Token::Eq)?;
    let path = self.expect_string()?;  // "path/to/file"
    self.expect(Token::Semicolon)?;
    
    Ok(Item::Resource { name, resource_type, path })
}
```

### Codegen Changes

**Resource Declaration:**
```rust
// src/codegen.rs
fn generate_resource(&mut self, item: &Resource) -> String {
    match item.resource_type {
        Type::Texture => {
            format!(r#"
// Resource: {}
Resource<Texture> g_resource_{}("{}");
"#, item.name, item.name.to_lowercase(), item.path)
        },
        Type::Mesh => {
            format!(r#"
// Resource: {}
Resource<Mesh> g_resource_{}("{}");
"#, item.name, item.name.to_lowercase(), item.path)
        },
        // ...
    }
}
```

---

## Example: Complete Resource Usage

### HEIDIC Code:
```heidic
// Load resources
resource BrickTexture = "textures/brick.png";
resource CubeMesh = "models/cube.obj";
resource PlayerMesh = "models/player.gltf";

fn main(): void {
    // Use resources directly
    let window = glfwCreateWindow(800, 600, "Game");
    heidic_init_renderer(window);
    
    // Resources are automatically loaded and ready
    draw_mesh(CubeMesh, BrickTexture);
}
```

### Generated C++:
```cpp
// Resources auto-initialized before main
Resource<Texture> g_resource_BrickTexture("textures/brick.png");
Resource<Mesh> g_resource_CubeMesh("models/cube.obj");
Resource<Mesh> g_resource_PlayerMesh("models/player.gltf");

int heidic_main() {
    GLFWwindow* window = glfwCreateWindow(800, 600, "Game");
    heidic_init_renderer(window);
    
    // Use resources
    draw_mesh(*g_resource_CubeMesh.get(), *g_resource_BrickTexture.get());
    return 0;
}
```

---

## Timeline

### Week 1: Texture Resources
- [ ] Add `resource` keyword to lexer/parser
- [ ] Implement texture loading (stb_image + Vulkan)
- [ ] Generate Resource<Texture> wrapper
- [ ] CONTINUUM hot-reload integration
- [ ] Test with bouncing_balls project

### Week 2: Mesh Resources (OBJ)
- [ ] Write OBJ parser (stdlib/obj_loader.h)
- [ ] Implement mesh loading (vertex/index buffers)
- [ ] Generate Resource<Mesh> wrapper
- [ ] Test with cube/sphere models

### Week 2-3: glTF Support
- [ ] Add tinygltf dependency OR write glTF parser
- [ ] Implement glTF loading
- [ ] Handle materials/textures from glTF
- [ ] Test with Sponza or similar complex model

### Week 3+: Custom .hdm Format
- [ ] Design .hdm binary format
- [ ] Write .hdm exporter (obj/gltf → hdm)
- [ ] Write .hdm loader (memory-mapped)
- [ ] Integrate into H_SCRIBE build process
- [ ] Benchmark vs OBJ/glTF (should be 10-100x faster)

---

## Decision: DDS Textures + OBJ Meshes First

**Recommendation:**
1. **Start with DDS textures** - 25-40× faster than PNG, production-ready
2. **Add OBJ meshes** - Simple, quick to implement, proves the resource system works
3. **Add glTF** - Industry standard, handles complex models
4. **Then add .hdm** - Optimized format once we have real usage patterns

**Why:**
- **DDS textures = instant win** - 1.1ms vs 28ms load time, massive performance gain
- OBJ gets us unblocked fast (no dependencies, ASCII parsing)
- glTF handles real-world models (games use glTF, not OBJ)
- .hdm is the optimization - add it when we know what we need

**Key Insight:** DDS support is **not optional** - it's the difference between a fast engine and a slow one!

**The .hdm format will be worth it** because:
- Binary = faster loading
- Cache-friendly layout = better performance
- SOA-compatible = ready for CUDA/OptiX
- Smaller file size = faster asset streaming

But let's get the resource system working with standard formats first, then optimize!

---

## Next Steps

1. ✅ **Start with DDS Texture Resources** (CRITICAL - 25-40× faster!)
2. ✅ **Add PNG → DDS Build Pipeline** (auto-convert source files)
3. ✅ **Add OBJ Mesh Loading** (proves the concept)
4. ✅ **Add glTF Support** (real-world models)
5. ✅ **Design .hdm Format** (performance optimization)

**Priority:** DDS texture support is **not optional** - it's the foundation of fast asset loading!

---

## Future: Custom .hti Format (Optional)

If we want to add metadata/LLM-friendliness later:

**`.hti` (HEIDIC Texture Image) Format:**
```
HEIDIC_TEXTURE v1.0
NAME: Cockpit Diffuse
SOURCE: cockpit_diffuse.png
INTENT: Albedo map for PBR material
COMPRESSION: BC7
GPU_READY: true
WIDTH: 2048
HEIGHT: 2048
MIPMAPS: 11
[BC7 compressed data follows...]
```

**Benefits:**
- LLM can read metadata (knows what texture is for)
- Still GPU-ready (BC7 compression)
- Self-documenting

**But:** DDS/KTX2 with build-time conversion gives 99% of the benefit with zero friction!

Let's start with DDS and get the foundation right!

