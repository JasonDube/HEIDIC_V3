// EDEN ENGINE - Gateway Editor v1
// Features: ImGui, Programmatic Cube, FPS Camera, Frame Control

// Include EDEN Engine standard library
include "stdlib/eden.hd";

// HEIDIC Functions for mesh instances
// These functions are called each frame for mesh instances that have them assigned

// Example function: rotate_me - rotates the mesh continuously
fn rotate_me(mesh_instance_id: i32): void {
    // Get current rotation
    let current_rx: f32 = heidic_get_mesh_instance_rx(mesh_instance_id);
    let current_ry: f32 = heidic_get_mesh_instance_ry(mesh_instance_id);
    let current_rz: f32 = heidic_get_mesh_instance_rz(mesh_instance_id);
    
    // Rotate around Y axis (1 degree per frame)
    let rotation_speed: f32 = 1.0;
    let new_ry: f32 = current_ry + rotation_speed;
    
    // Wrap around at 360 degrees
    if new_ry >= 360.0 {
        new_ry = new_ry - 360.0;
    }
    
    // Apply new rotation
    heidic_set_mesh_instance_rotation(mesh_instance_id, current_rx, new_ry, current_rz);
}

fn main(): void {
    // Visibility constants
    let VISIBLE: i32 = 1;
    let INVISIBLE: i32 = 0;
    print("Initializing GLFW...\n");
    if heidic_glfw_init() == 0 {
        return;
    }
    
    heidic_glfw_vulkan_hints();
    let window: GLFWwindow = heidic_create_window(1300, 700, "EDEN ENGINE - Gateway Editor v1");
    
    if heidic_init_renderer(window) == 0 {
        heidic_glfw_terminate();
        return;
    }
    
    // Load ImGui layout on startup
    let default_ini_path_load: string = "";
    heidic_imgui_load_layout(default_ini_path_load);
    
    // Auto-load a model and light at startup for faster iteration
    print("Auto-loading model and light at startup...\n");
    // Path is relative to project root (executable runs from examples/gateway_editor_v1/)
    let auto_model_path: string = "../../models/eve_1.obj";
    let auto_mesh_id: i32 = heidic_load_obj_mesh(auto_model_path);
    if auto_mesh_id >= 0 {
        print("Auto-loaded model: ");
        print(auto_model_path);
        print(" (ID: ");
        print(auto_mesh_id);
        print(")\n");
        
        // Try to auto-load texture if it exists
        let auto_texture_path: string = "../../models/Textures/eve_tex.png";
        heidic_set_mesh_instance_texture(auto_mesh_id, auto_texture_path);
    } else {
        print("Failed to auto-load model, continuing anyway...\n");
    }
    
    // Create a directional light pointing at the model
    // Position light above the model, pointing down
    let light_x: f32 = 0.0;
    let light_y: f32 = 500.0; // 5 meters above
    let light_z: f32 = 0.0;
    let light_dir_x: f32 = 0.0;
    let light_dir_y: f32 = -1.0; // Pointing down
    let light_dir_z: f32 = 0.0;
    let auto_light_id: i32 = heidic_create_directional_light(light_x, light_y, light_z, light_dir_x, light_dir_y, light_dir_z);
    if auto_light_id >= 0 {
        print("Auto-created directional light (ID: ");
        print(auto_light_id);
        print(") at (");
        print(light_x);
        print(", ");
        print(light_y);
        print(", ");
        print(light_z);
        print(") pointing (");
        print(light_dir_x);
        print(", ");
        print(light_dir_y);
        print(", ");
        print(light_dir_z);
        print(")\n");
    } else {
        print("Failed to auto-create light, continuing anyway...\n");
    }
    
    // Start in windowed mode (1 = windowed)
    // Video mode: 0 = fullscreen, 1 = windowed
    
    // Player (Cube) Transform - using Vec3 for position and rotation
    // Spawn player at (100, 100, 100) - camera will be at (100, 200, 100)
    let player_pos: Vec3 = heidic_vec3(100.0, 100.0, 100.0);
    let player_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Camera Transform - will follow player with offset
    // Initial position will be set in loop with offset
    let camera_pos: Vec3 = heidic_vec3(0.0, 100.0, 0.0); // Will be updated in loop
    let camera_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Legacy variables for drawing (will be updated from Vec3)
    let cube_x: f32 = 0.0;
    let cube_y: f32 = 0.0;
    let cube_z: f32 = 0.0;
    let cube_rx: f32 = 0.0;
    let cube_ry: f32 = 0.0;
    let cube_rz: f32 = 0.0;
    
    // Cube Size (100 cm = 1 meter)
    let cube_sx: f32 = 100.0;
    let cube_sy: f32 = 100.0;
    let cube_sz: f32 = 100.0;
    
    // Movement Speed (cm per frame)
    let move_speed: f32 = 15.0; // Increased from 5.0 for faster movement
    let slow_speed_mode: i32 = 0; // 0 = normal speed, 1 = slow speed
    let normal_speed: f32 = 15.0;
    let slow_speed: f32 = 1.0; // Very slow for detailed inspection
    
    // Rotation Speed (degrees per frame) - for Q/E keys (optional, mouse look is primary)
    let rot_speed: f32 = 2.0;
    
    // Mouse Look Sensitivity (degrees per pixel)
    let mouse_sensitivity: f32 = 0.1;
    
    // Pitch clamp limits (for camera rotation)
    let pitch_max: f32 = 90.0;
    let pitch_min: f32 = -90.0;
    
    // Debug UI State
    let show_debug: i32 = 1;
    let f1_was_pressed: i32 = 0;
    
    // Player cube visibility: Always invisible in FPS mode
    let player_cube_visible: i32 = INVISIBLE;
    
    // Mouse mode: 0 = build mode (cursor captured, crosshair visible, right-click to place blocks), 1 = selection mode (cursor visible, left-click to select/interact)
    let mouse_mode: i32 = 0; // Start in build mode (mouse mode 0)
    let mouse_mode_left_was_pressed: i32 = 0;
    let mouse_mode_right_was_pressed: i32 = 0;
    
    // Set cursor mode based on initial mouse mode (build mode = captured)
    heidic_set_cursor_mode(window, 2); // 2 = disabled (captured) for FPS mode in build mode
    
    // Grid visibility toggle
    let show_grid: i32 = 0; // Start with grid hidden
    let g_was_pressed: i32 = 0;
    
    // Video Mode: 0 = fullscreen, 1 = windowed
    let video_mode: i32 = 1; // Start in windowed mode
    let shift_enter_was_pressed: i32 = 0;
    
    // Selection state
    let selected_cube_x: f32 = 0.0;
    let selected_cube_y: f32 = 0.0;
    let selected_cube_z: f32 = 0.0;
    let selected_cube_sx: f32 = 0.0;
    let selected_cube_sy: f32 = 0.0;
    let selected_cube_sz: f32 = 0.0;
    let has_selection: i32 = 0; // 0 = no selection, 1 = has selection
    
    // Stored preview position (calculated every frame, used for actual placement)
    let stored_preview_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    let stored_preview_valid: i32 = 0; // 1 = preview position is valid and ready to use
    let selected_cube_index: f32 = -1.0; // -1.0 = none, 0.0 = player, >= 2.0 = created cubes, >= 10000.0 = mesh instances
    
    // Mesh selection state
        let selected_mesh_instance_id: i32 = -1; // -1 = none, >= 0 = mesh instance ID
    let selected_mesh_x: f32 = 0.0;
    let selected_mesh_y: f32 = 0.0;
    let selected_mesh_z: f32 = 0.0;
    let has_mesh_selection: i32 = 0; // 0 = no mesh selection, 1 = has mesh selection
    
    // Wedge selection state
    let selected_wedge_index: i32 = -1; // -1 = none, >= 0 = wedge index
    let selected_wedge_x: f32 = 0.0;
    let selected_wedge_y: f32 = 0.0;
    let selected_wedge_z: f32 = 0.0;
    let selected_wedge_sx: f32 = 0.0;
    
    // Light selection state
    let selected_light_id: i32 = -1; // -1 = none, >= 0 = light ID
    let selected_light_x: f32 = 0.0;
    let selected_light_y: f32 = 0.0;
    let selected_light_z: f32 = 0.0;
    let selected_light_dir_x: f32 = 0.0;
    let selected_light_dir_y: f32 = 0.0;
    let selected_light_dir_z: f32 = 0.0;
    let has_light_selection: i32 = 0; // 0 = no light selection, 1 = has light selection
    let selected_wedge_sy: f32 = 0.0;
    let selected_wedge_sz: f32 = 0.0;
    let has_wedge_selection: i32 = 0; // 0 = no wedge selection, 1 = has wedge selection
    
    // Window visibility flags (1 = visible, 0 = hidden)
    let show_codex_window: i32 = 1; // Codex Of Forms
    let show_texture_swatches_window: i32 = 1; // Texture Swatches
    let show_uv_editor_window: i32 = 1; // UV Editor
    let show_performance_info_window: i32 = 1; // Performance Info
    
    // Ground detection
    let is_grounded: i32 = 0;
    
    // Mouse button state tracking
    let mouse_left_was_pressed: i32 = 0;
    let mouse_middle_was_pressed: i32 = 0;
    
    // Delete key state tracking
    let delete_was_pressed: i32 = 0;
    let key_0_was_pressed: i32 = 0;  // Key '0' for wedge creation (deprecated - now use build mode)
    
    // Build mode: 0 = cube mode, 1 = wedge mode, 2 = directional light mode, 3 = point light mode, 4 = spot light mode
    let build_mode: i32 = 0; // Default to cube mode
    let key_1_was_pressed: i32 = 0; // Key '1' to switch to cube mode
    let key_2_was_pressed: i32 = 0; // Key '2' to switch to wedge mode
    let key_3_was_pressed: i32 = 0; // Key '3' to switch to directional light mode
    let key_4_was_pressed: i32 = 0; // Key '4' to switch to point light mode
    let key_5_was_pressed: i32 = 0; // Key '5' to switch to spot light mode
    
    // Wedge preview rotation (0-11, cycling through 12 custom orientations)
    // Custom rotation values for each position:
    // pos 0 = 270, 180, 90
    // pos 1 = 180, 90, 270
    // pos 2 = 90, 270, 180
    // pos 3 = 180, 0, 270
    // pos 4 = 180, 180, 90
    // pos 5 = 180, 90, 90
    // pos 6 = 180, 270, 90
    // pos 7 = 180, 0, 90
    // pos 8 = 180, 90, 180
    // pos 9 = 90, 270, 270
    // pos 10 = 90, 270, 90
    // pos 11 = 180, 0, 180
    let wedge_preview_rotation: i32 = 0;  // Start at position 0
    let last_wedge_preview_rotation: i32 = -1; // Track previous rotation to detect changes
    
    // C key state tracking (for combining cubes - separate from camera toggle C key)
    let combine_c_was_pressed: i32 = 0;
    let smooth_s_was_pressed: i32 = 0;
    
    // Level name buffer for input (managed by C++ side)
    // We'll use heidic_get_level_name() to get the current name
    
    // Dolly orbit state (for orbiting around selected object) - deprecated
    let dolly_orbit_azimuth: f32 = 0.0; // Horizontal angle around target
    let dolly_orbit_elevation: f32 = 45.0; // Vertical angle (0 = horizontal, 90 = straight up)
    let dolly_orbit_distance: f32 = 2000.0; // Distance from target (reduced from 5000 to 20 meters)
    let in_orbit_mode: i32 = 0; // Flag to prevent pan from overwriting orbit position (deprecated - Alt+dolly removed)
    
    // Reference Cube 1 removed - all cubes are now created dynamically
    
    // Spacebar state
    let space_was_pressed: i32 = 0;
    
    // Created cube size (2 meters = 200 units)
    let created_cube_size: f32 = 200.0;
    
    print("Starting loop...\n");
    
    while heidic_window_should_close(window) == 0 {
        heidic_poll_events();
        
        // Check if we're editing a combination name - if so, block all input except Enter/Escape
        let is_editing_combination: i32 = heidic_get_editing_combination_id();
        let block_input: i32 = 0;
        if is_editing_combination >= 0 {
            block_input = 1;
        }
        
        // Get mouse position and ray (always available for debug panel)
        let mouse_x: f32 = heidic_get_mouse_x(window);
        let mouse_y: f32 = heidic_get_mouse_y(window);
        
        // Get ray from center of screen (for crosshair targeting) or mouse position (for selection)
        let ray_origin: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
        let ray_dir: Vec3 = heidic_vec3(0.0, 0.0, 1.0);
        if mouse_mode == 0 {
            // Build mode: use center of screen for raycast
            ray_origin = heidic_get_center_ray_origin(window);
            ray_dir = heidic_get_center_ray_dir(window);
        } else {
            // Selection mode: use mouse position for raycast
            ray_origin = heidic_get_mouse_ray_origin(window);
            ray_dir = heidic_get_mouse_ray_dir(window);
        }
        
        // ESC: Exit from build mode to selection mode (or stop editing)
        if heidic_is_key_pressed(window, 256) == 1 { // ESC
            // If editing, stop editing
            if is_editing_combination >= 0 {
                heidic_stop_editing_combination_name();
            } else {
                if mouse_mode == 0 {
                    // In build mode: switch to selection mode
                    mouse_mode = 1;
                    heidic_set_cursor_mode(window, 0); // 0 = normal (visible cursor)
                }
            }
        }
        
        // F12: Exit the editor
        if heidic_is_key_pressed(window, 301) == 1 { // F12
            heidic_set_window_should_close(window, 1);
        }
        
        // Alt + Mouse Drag dolly functionality has been removed/deprecated
        
        // Skip all other input if we're editing
        if block_input == 0 {
        
        // F1 Toggle Logic (290 is F1)
        let f1_is_pressed: i32 = heidic_is_key_pressed(window, 290);
        if f1_is_pressed == 1 {
            if f1_was_pressed == 0 {
                if show_debug == 1 {
                    show_debug = 0;
                } else {
                    show_debug = 1;
                }
                f1_was_pressed = 1;
            }
        } else {
            f1_was_pressed = 0;
        }
        
        // Component Mode Toggle (Key '1' = component mode, Key '2' = object mode)
        // Key code 49 = '1', 50 = '2'
        
        // Mouse Look (only when mouse_mode is disabled)
        if mouse_mode == 0 {
            // Get mouse delta
            let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
            let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
            
            // Update yaw (horizontal rotation) - rotate around Y axis
            // Reversed: mouse right = turn right (natural FPS feel)
            player_rot.y = player_rot.y - mouse_delta_x * mouse_sensitivity;
            
            // Update pitch (vertical rotation) - rotate around X axis
            // Clamp pitch to prevent flipping (typically -90 to +90 degrees)
            player_rot.x = player_rot.x - mouse_delta_y * mouse_sensitivity;
            
            // Clamp pitch to prevent camera flipping
            if player_rot.x > pitch_max {
                player_rot.x = pitch_max;
            }
            // Clamp minimum pitch (check if pitch_min is greater than current - inverted logic)
            let pitch_check: f32 = pitch_min - player_rot.x;
            if pitch_check > 0.0 {
                player_rot.x = pitch_min;
            }
        }
        
        // G Key Toggle Logic (71 is G) - Toggle ground plane grid visibility
        let g_is_pressed: i32 = heidic_is_key_pressed(window, 71);
        if g_is_pressed == 1 {
            if g_was_pressed == 0 {
                if show_grid == 1 {
                    show_grid = 0; // Hide grid
                } else {
                    show_grid = 1; // Show grid
                }
                g_was_pressed = 1;
            }
        } else {
            g_was_pressed = 0;
        }
        
        // Build mode switching: '1' = cube mode, '2' = wedge mode
        let key_1_pressed: i32 = heidic_is_key_pressed(window, 49); // ASCII '1'
        if key_1_pressed == 1 {
            if key_1_was_pressed == 0 {
                build_mode = 0; // Switch to cube mode
                print("Build mode: Cube\n");
            }
            key_1_was_pressed = 1;
        } else {
            key_1_was_pressed = 0;
        }
        
        let key_2_pressed: i32 = heidic_is_key_pressed(window, 50); // ASCII '2'
        if key_2_pressed == 1 {
            if key_2_was_pressed == 0 {
                build_mode = 1; // Switch to wedge mode
                print("Build mode: Wedge\n");
            }
            key_2_was_pressed = 1;
        } else {
            key_2_was_pressed = 0;
        }
        
        let key_3_pressed: i32 = heidic_is_key_pressed(window, 51); // ASCII '3'
        if key_3_pressed == 1 {
            if key_3_was_pressed == 0 {
                build_mode = 2; // Switch to directional light mode
                print("Build mode: Directional Light\n");
            }
            key_3_was_pressed = 1;
        } else {
            key_3_was_pressed = 0;
        }
        
        let key_4_pressed: i32 = heidic_is_key_pressed(window, 52); // ASCII '4'
        if key_4_pressed == 1 {
            if key_4_was_pressed == 0 {
                build_mode = 3; // Switch to point light mode
                print("Build mode: Point Light\n");
            }
            key_4_was_pressed = 1;
        } else {
            key_4_was_pressed = 0;
        }
        
        let key_5_pressed: i32 = heidic_is_key_pressed(window, 53); // ASCII '5'
        if key_5_pressed == 1 {
            if key_5_was_pressed == 0 {
                build_mode = 4; // Switch to spot light mode
                print("Build mode: Spot Light\n");
            }
            key_5_was_pressed = 1;
        } else {
            key_5_was_pressed = 0;
        }
        
        // Mouse wheel rotation for wedge preview (only in wedge mode)
        if build_mode == 1 {
            let mouse_scroll: f32 = heidic_get_mouse_scroll_y(window);
            // Use a threshold to handle fractional scroll values (trackpads, high-DPI mice)
            // Accumulate small values until we get a meaningful scroll
            let scroll_threshold: f32 = 0.1; // Minimum scroll amount to trigger rotation
            
            // Process scroll even if ImGui wants mouse - we capture it before ImGui
            // But only if we're not hovering over an ImGui window (to avoid conflicts)
            if heidic_imgui_wants_mouse() == 0 {
                if mouse_scroll > scroll_threshold {
                    // Scroll up (pulling): cycle backward through 12 orientations (0 -> 11 -> ... -> 1 -> 0)
                    wedge_preview_rotation = wedge_preview_rotation - 1;
                    if wedge_preview_rotation < 0 {
                        wedge_preview_rotation = 11;
                    }
                } else {
                    if mouse_scroll < -scroll_threshold {
                        // Scroll down (pushing): cycle forward through 12 orientations (0 -> 1 -> ... -> 11 -> 0)
                        wedge_preview_rotation = wedge_preview_rotation + 1;
                        if wedge_preview_rotation > 11 {
                            wedge_preview_rotation = 0;
                        }
                    }
                }
            }
        }
        
        // Get mouse button states (used for both block placement and mode switching)
        let mouse_right_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
        
        // Right-click (button 1) - Create new cube or wedge at center ray hit point (only in build mode, mouse_mode == 0)
        // Uses center of screen raycast for precise targeting
        if mouse_mode == 0 && mouse_right_pressed == 1 {
            if mouse_mode_right_was_pressed == 0 {
                print("RIGHT-CLICK PRESSED! Creating block at center ray hit point\n");
                
                // Default cube size (1 meter = 100 units)
                let default_cube_size: f32 = 100.0;
                
                // Use the stored preview position if available (calculated this frame)
                // This ensures exact match between preview and placement
                let create_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                if stored_preview_valid == 1 {
                    // Use the preview position directly - this is exactly where the red cube is
                    create_pos = stored_preview_pos;
                    print("Using stored preview position for block placement\n");
                } else {
                    // Fallback: calculate placement (shouldn't happen, but just in case)
                    print("WARNING: No valid preview position, calculating placement\n");
                    
                    // Use center ray to find where to place the block
                    let create_ray_origin: Vec3 = heidic_get_center_ray_origin(window);
                    let create_ray_dir: Vec3 = heidic_get_center_ray_dir(window);
                let found_hit: i32 = 0;
                let closest_dist: f32 = 100000000000.0; // Very large distance
                let hit_cube_x: f32 = 0.0;
                let hit_cube_y: f32 = 0.0;
                let hit_cube_z: f32 = 0.0;
                let hit_cube_sx: f32 = 0.0;
                let hit_cube_sy: f32 = 0.0;
                let hit_cube_sz: f32 = 0.0;
                let hit_point: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                let is_ground_plane: i32 = 0;
                let is_wedge: i32 = 0; // 1 = hit object is a wedge, 0 = cube or other
                
                // FIRST: Test the big grey ground plane cube (100m x 100m x 1m, top at y = 0)
                // This is important geometry and needs to be pickable!
                let ground_cube_x: f32 = 0.0;
                let ground_cube_y: f32 = -50.0; // Center at -0.5m so top is at y=0
                let ground_cube_z: f32 = 0.0;
                let ground_cube_sx: f32 = 10000.0; // 100 meters
                let ground_cube_sy: f32 = 100.0;   // 1 meter thick
                let ground_cube_sz: f32 = 10000.0; // 100 meters
                
                // Also test the vertical side plane (100m x 100m x 1m, bottom at y=0, 50m out from center)
                let side_cube_x: f32 = 5000.0; // 50 meters out
                let side_cube_y: f32 = 5000.0; // 50 meters up (center, so bottom at y=0)
                let side_cube_z: f32 = 0.0;
                let side_cube_sx: f32 = 100.0;   // 1 meter thick (in X direction after rotation)
                let side_cube_sy: f32 = 10000.0; // 100 meters tall (in Y direction)
                let side_cube_sz: f32 = 10000.0; // 100 meters wide (in Z direction)
                
                let ground_cube_hit: i32 = heidic_raycast_cube_hit_center(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                if ground_cube_hit == 1 {
                    let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point_center(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                    let ground_cube_dist: f32 = (ground_cube_hit_point.x - create_ray_origin.x) * (ground_cube_hit_point.x - create_ray_origin.x) + (ground_cube_hit_point.y - create_ray_origin.y) * (ground_cube_hit_point.y - create_ray_origin.y) + (ground_cube_hit_point.z - create_ray_origin.z) * (ground_cube_hit_point.z - create_ray_origin.z);
                    if ground_cube_dist < closest_dist {
                        closest_dist = ground_cube_dist;
                        create_pos = ground_cube_hit_point;
                        hit_point = ground_cube_hit_point;
                        hit_cube_x = ground_cube_x;
                        hit_cube_y = ground_cube_y;
                        hit_cube_z = ground_cube_z;
                        hit_cube_sx = ground_cube_sx;
                        hit_cube_sy = ground_cube_sy;
                        hit_cube_sz = ground_cube_sz;
                        is_ground_plane = 1;
                        found_hit = 1;
                    }
                }
                
                // Test vertical side plane
                let side_cube_hit: i32 = heidic_raycast_cube_hit_center(window, side_cube_x, side_cube_y, side_cube_z, side_cube_sx, side_cube_sy, side_cube_sz);
                if side_cube_hit == 1 {
                    let side_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point_center(window, side_cube_x, side_cube_y, side_cube_z, side_cube_sx, side_cube_sy, side_cube_sz);
                    let side_cube_dist: f32 = (side_cube_hit_point.x - create_ray_origin.x) * (side_cube_hit_point.x - create_ray_origin.x) + (side_cube_hit_point.y - create_ray_origin.y) * (side_cube_hit_point.y - create_ray_origin.y) + (side_cube_hit_point.z - create_ray_origin.z) * (side_cube_hit_point.z - create_ray_origin.z);
                    if side_cube_dist < closest_dist {
                        closest_dist = side_cube_dist;
                        create_pos = side_cube_hit_point;
                        hit_point = side_cube_hit_point;
                        hit_cube_x = side_cube_x;
                        hit_cube_y = side_cube_y;
                        hit_cube_z = side_cube_z;
                        hit_cube_sx = side_cube_sx;
                        hit_cube_sy = side_cube_sy;
                        hit_cube_sz = side_cube_sz;
                        is_ground_plane = 0; // Side plane is not the ground plane
                        found_hit = 1;
                    }
                }
                
                // Test all created cubes to find closest hit
                let cube_test_index: i32 = 0;
                let total_cubes_test: i32 = heidic_get_cube_total_count();
                while cube_test_index < total_cubes_test {
                    if heidic_get_cube_active(cube_test_index) == 1 {
                        let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                        let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                        let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                        let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                        let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                        let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                        
                        let cube_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                        if cube_hit == 1 {
                            let test_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            let dist: f32 = (test_hit_point.x - create_ray_origin.x) * (test_hit_point.x - create_ray_origin.x) + (test_hit_point.y - create_ray_origin.y) * (test_hit_point.y - create_ray_origin.y) + (test_hit_point.z - create_ray_origin.z) * (test_hit_point.z - create_ray_origin.z);
                            if dist < closest_dist {
                                closest_dist = dist;
                                create_pos = test_hit_point;
                                // Store the hit cube's position, size, and hit point for face detection
                                hit_point = test_hit_point;
                                hit_cube_x = test_cube_x;
                                hit_cube_y = test_cube_y;
                                hit_cube_z = test_cube_z;
                                hit_cube_sx = test_cube_sx;
                                hit_cube_sy = test_cube_sy;
                                hit_cube_sz = test_cube_sz;
                                is_ground_plane = 0;
                                found_hit = 1;
                            }
                        }
                    }
                    cube_test_index = cube_test_index + 1;
                }
                
                if found_hit == 1 {
                    // Ray hit a cube or ground plane - use same calculation as preview
                    if is_ground_plane == 1 {
                        // Ground plane: always stack on top
                        let hit_top_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        create_pos.y = hit_top_y + default_cube_size / 2.0;
                        create_pos.x = hit_point.x;
                        create_pos.z = hit_point.z;
                        print("Hit ground plane! Stacking on top\n");
                    } else {
                        // Regular cube or wedge: use exact same calculation as preview
                        // Calculate bounds
                        let cube_min_x: f32 = hit_cube_x - hit_cube_sx / 2.0;
                        let cube_max_x: f32 = hit_cube_x + hit_cube_sx / 2.0;
                        let cube_min_y: f32 = hit_cube_y - hit_cube_sy / 2.0;
                        let cube_max_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        let cube_min_z: f32 = hit_cube_z - hit_cube_sz / 2.0;
                        let cube_max_z: f32 = hit_cube_z + hit_cube_sz / 2.0;
                        
                        // Calculate distances from hit point to each face
                        let dist_to_left: f32 = hit_point.x - cube_min_x;
                        let dist_to_right: f32 = cube_max_x - hit_point.x;
                        let dist_to_bottom: f32 = hit_point.y - cube_min_y;
                        let dist_to_top: f32 = cube_max_y - hit_point.y;
                        let dist_to_back: f32 = hit_point.z - cube_min_z;
                        let dist_to_front: f32 = cube_max_z - hit_point.z;
                        
                        // Find the closest face (same logic as preview)
                        // For both cubes and wedges, check all 6 faces of the bounding box
                        // (Wedges are inscribed in a cube, so we treat them the same as cubes)
                        let min_dist: f32 = dist_to_left;
                        let hit_face: i32 = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
                        
                        // Check all faces (works for both cubes and wedges)
                        if dist_to_right < min_dist {
                            min_dist = dist_to_right;
                            hit_face = 1;
                        }
                        if dist_to_bottom < min_dist {
                            min_dist = dist_to_bottom;
                            hit_face = 2;
                        }
                        if dist_to_top < min_dist {
                            min_dist = dist_to_top;
                            hit_face = 3;
                        }
                        if dist_to_back < min_dist {
                            min_dist = dist_to_back;
                            hit_face = 4;
                        }
                        if dist_to_front < min_dist {
                            min_dist = dist_to_front;
                            hit_face = 5;
                        }
                        
                        // Calculate placement position (exact same logic as preview)
                        if hit_face == 0 {
                            // Left face (negative X) - stack to the left
                            create_pos.x = cube_min_x - default_cube_size / 2.0;
                            create_pos.y = hit_cube_y;
                            create_pos.z = hit_cube_z;
                            print("Hit left face! Stacking to the left\n");
                        } else {
                            if hit_face == 1 {
                                // Right face (positive X) - stack to the right
                                create_pos.x = cube_max_x + default_cube_size / 2.0;
                                create_pos.y = hit_cube_y;
                                create_pos.z = hit_cube_z;
                                print("Hit right face! Stacking to the right\n");
                            } else {
                                if hit_face == 2 {
                                    // Bottom face (negative Y) - stack below
                                    create_pos.x = hit_cube_x;
                                    create_pos.y = cube_min_y - default_cube_size / 2.0;
                                    create_pos.z = hit_cube_z;
                                    print("Hit bottom face! Stacking below\n");
                                } else {
                                    if hit_face == 3 {
                                        // Top face (positive Y) - stack on top
                                        create_pos.x = hit_cube_x;
                                        create_pos.y = cube_max_y + default_cube_size / 2.0;
                                        create_pos.z = hit_cube_z;
                                        print("Hit top face! Stacking on top\n");
                                    } else {
                                        if hit_face == 4 {
                                            // Back face (negative Z) - stack to the back
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_min_z - default_cube_size / 2.0;
                                            print("Hit back face! Stacking to the back\n");
                                        } else {
                                            // Front face (positive Z) - stack to the front
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_max_z + default_cube_size / 2.0;
                                            print("Hit front face! Stacking to the front\n");
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // No hit - place cube 5 meters (500 units) along the ray
                    create_pos = heidic_vec3_add(create_ray_origin, heidic_vec3_mul_scalar(create_ray_dir, 500.0));
                    print("No hit, placing cube along ray\n");
                }
                } // End of fallback calculation (if stored_preview_valid == 0)
                
                // Generate random color for the new block
                // Use white color (1,1,1) so texture displays at full brightness
                let block_r: f32 = 1.0;
                let block_g: f32 = 1.0;
                let block_b: f32 = 1.0;
                
                // Create block based on build mode
                let block_index: i32 = -1;
                if build_mode == 0 {
                    // Cube mode: create cube
                    block_index = heidic_create_cube_with_color(create_pos.x, create_pos.y, create_pos.z, default_cube_size, default_cube_size, default_cube_size, block_r, block_g, block_b);
                    print("Created cube at index: ");
                } else {
                    if build_mode == 2 {
                        // Directional light mode: create directional light
                        // Default direction: down (-Y)
                        let light_dir_x: f32 = 0.0;
                        let light_dir_y: f32 = -1.0;
                        let light_dir_z: f32 = 0.0;
                        let light_id: i32 = heidic_create_directional_light(create_pos.x, create_pos.y, create_pos.z, light_dir_x, light_dir_y, light_dir_z);
                        print("Created directional light at index: ");
                        print(light_id);
                        print("\n");
                    } else {
                        if build_mode == 3 {
                            // Point light mode: create point light
                            // Default: white light, intensity 1.0, range 1000.0
                            let light_r: f32 = 1.0;
                            let light_g: f32 = 1.0;
                            let light_b: f32 = 1.0;
                            let light_intensity: f32 = 1.0;
                            let light_range: f32 = 1000.0;
                            let light_id: i32 = heidic_create_point_light(create_pos.x, create_pos.y, create_pos.z, light_r, light_g, light_b, light_intensity, light_range);
                            print("Created point light at index: ");
                            print(light_id);
                            print("\n");
                        } else {
                            if build_mode == 4 {
                                // Spot light mode: create spot light
                                // Default: white light, intensity 1.0, range 200.0 (smaller for intuitive placement)
                                // Direction: down (0, -1, 0)
                                // Inner cone: 0.0 radians (0 degrees - no inner falloff)
                                // Outer cone: 0.785 radians (45 degrees)
                                let light_r: f32 = 1.0;
                                let light_g: f32 = 1.0;
                                let light_b: f32 = 1.0;
                                let light_intensity: f32 = 1.0;
                                let light_range: f32 = 200.0;  // Smaller default for easier placement
                                let dir_x: f32 = 0.0;
                                let dir_y: f32 = -1.0;
                                let dir_z: f32 = 0.0;
                                let inner_cone: f32 = 0.0;  // 0 degrees
                                let outer_cone: f32 = 0.785;  // 45 degrees (PI/4)
                                let light_id: i32 = heidic_create_spot_light(create_pos.x, create_pos.y, create_pos.z, dir_x, dir_y, dir_z, light_r, light_g, light_b, light_intensity, light_range, inner_cone, outer_cone);
                                print("Created spot light at index: ");
                                print(light_id);
                                print("\n");
                            } else {
                                // Wedge mode: create wedge with rotation
                                // Custom rotation values for each of the 12 positions
                                let wedge_rot_x: f32 = 0.0;
                                let wedge_rot_y: f32 = 0.0;
                                let wedge_rot_z: f32 = 0.0;
                                
                                if wedge_preview_rotation == 0 {
                                    wedge_rot_x = 270.0;
                                    wedge_rot_y = 180.0;
                                    wedge_rot_z = 90.0;
                                } else {
                                    if wedge_preview_rotation == 1 {
                                        wedge_rot_x = 180.0;
                                        wedge_rot_y = 90.0;
                                        wedge_rot_z = 270.0;
                                    } else {
                                        if wedge_preview_rotation == 2 {
                                            wedge_rot_x = 90.0;
                                            wedge_rot_y = 270.0;
                                            wedge_rot_z = 180.0;
                                        } else {
                                            if wedge_preview_rotation == 3 {
                                                wedge_rot_x = 180.0;
                                                wedge_rot_y = 0.0;
                                                wedge_rot_z = 270.0;
                                            } else {
                                                if wedge_preview_rotation == 4 {
                                                    wedge_rot_x = 180.0;
                                                    wedge_rot_y = 180.0;
                                                    wedge_rot_z = 90.0;
                                                } else {
                                                    if wedge_preview_rotation == 5 {
                                                        wedge_rot_x = 180.0;
                                                        wedge_rot_y = 90.0;
                                                        wedge_rot_z = 90.0;
                                                    } else {
                                                        if wedge_preview_rotation == 6 {
                                                            wedge_rot_x = 180.0;
                                                            wedge_rot_y = 270.0;
                                                            wedge_rot_z = 90.0;
                                                        } else {
                                                            if wedge_preview_rotation == 7 {
                                                                wedge_rot_x = 180.0;
                                                                wedge_rot_y = 0.0;
                                                                wedge_rot_z = 90.0;
                                                            } else {
                                                                if wedge_preview_rotation == 8 {
                                                                    wedge_rot_x = 180.0;
                                                                    wedge_rot_y = 90.0;
                                                                    wedge_rot_z = 180.0;
                                                                } else {
                                                                    if wedge_preview_rotation == 9 {
                                                                        wedge_rot_x = 90.0;
                                                                        wedge_rot_y = 270.0;
                                                                        wedge_rot_z = 270.0;
                                                                    } else {
                                                                        if wedge_preview_rotation == 10 {
                                                                            wedge_rot_x = 90.0;
                                                                            wedge_rot_y = 270.0;
                                                                            wedge_rot_z = 90.0;
                                                                        } else {
                                                                            if wedge_preview_rotation == 11 {
                                                                                wedge_rot_x = 180.0;
                                                                                wedge_rot_y = 0.0;
                                                                                wedge_rot_z = 180.0;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                block_index = heidic_create_wedge_with_color(create_pos.x, create_pos.y, create_pos.z, default_cube_size, default_cube_size, default_cube_size, block_r, block_g, block_b);
                                // Set the wedge rotation
                                heidic_set_wedge_rotation(block_index, wedge_rot_x, wedge_rot_y, wedge_rot_z);
                                print("Created wedge at index: ");
                            }
                        }
                    }
                }
                
                if block_index >= 0 {
                    print(block_index);
                    print("\n");
                    
                    // Select the newly created block based on build mode
                    if build_mode == 0 {
                        // Cube mode: use cube selection
                        has_selection = 1;
                        // Convert index to float and add 2.0 offset
                        selected_cube_index = heidic_int_to_float(block_index) + 2.0;
                        // Update selected cube properties for gizmo
                        selected_cube_x = create_pos.x;
                        selected_cube_y = create_pos.y;
                        selected_cube_z = create_pos.z;
                        selected_cube_sx = default_cube_size;
                        selected_cube_sy = default_cube_size;
                        selected_cube_sz = default_cube_size;
                        // Clear wedge and mesh selection
                        has_wedge_selection = 0;
                        selected_wedge_index = -1;
                        has_mesh_selection = 0;
                        selected_mesh_instance_id = -1;
                    } else {
                        // Wedge mode: use wedge selection
                        has_wedge_selection = 1;
                        selected_wedge_index = block_index;
                        selected_wedge_x = create_pos.x;
                        selected_wedge_y = create_pos.y;
                        selected_wedge_z = create_pos.z;
                        selected_wedge_sx = default_cube_size;
                        selected_wedge_sy = default_cube_size;
                        selected_wedge_sz = default_cube_size;
                        // Clear cube and mesh selection
                        has_selection = 0;
                        selected_cube_index = -1.0;
                        has_mesh_selection = 0;
                        selected_mesh_instance_id = -1;
                    }
                } else {
                    if build_mode == 0 {
                        print("Failed to create cube\n");
                    } else {
                        print("Failed to create wedge\n");
                    }
                }
                
                mouse_mode_right_was_pressed = 1;
            }
        } else {
            mouse_mode_right_was_pressed = 0;
        }
            
            // Key '0' (48) - Create wedge at mouse ray hit point (simplified - just stack on top)
            let key_0_pressed: i32 = heidic_is_key_pressed(window, 48);
            if key_0_pressed == 1 {
                if key_0_was_pressed == 0 {
                    print("KEY '0' PRESSED! Creating wedge at ray hit point\n");
                    
                    // Default wedge size (1 meter = 100 units, same as cube)
                    let default_wedge_size: f32 = 100.0;
                    
                    // Always use mouse ray to find where to place the wedge
                    let create_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
                    let create_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
                    
                    // Simple: just test ground plane and place wedge on top
                    let create_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                    let found_hit: i32 = 0;
                    
                    // Test ground plane
                    let ground_cube_x: f32 = 0.0;
                    let ground_cube_y: f32 = -500.0;
                    let ground_cube_z: f32 = 0.0;
                    let ground_cube_sx: f32 = 10000.0;
                    let ground_cube_sy: f32 = 100.0;
                    let ground_cube_sz: f32 = 10000.0;
                    
                    let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                    if ground_cube_hit == 1 {
                        let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                        create_pos.y = ground_cube_y + ground_cube_sy / 2.0 + default_wedge_size / 2.0;
                        create_pos.x = ground_cube_hit_point.x;
                        create_pos.z = ground_cube_hit_point.z;
                        found_hit = 1;
                    } else {
                        // No hit - place wedge 5 meters (500 units) along the ray
                        create_pos = heidic_vec3_add(create_ray_origin, heidic_vec3_mul_scalar(create_ray_dir, 500.0));
                    }
                    
                    // Create wedge with white color (full texture brightness)
                    let wedge_r: f32 = 1.0;
                    let wedge_g: f32 = 1.0;
                    let wedge_b: f32 = 1.0;
                    
                    let wedge_index: i32 = heidic_create_wedge_with_color(create_pos.x, create_pos.y, create_pos.z, default_wedge_size, default_wedge_size, default_wedge_size, wedge_r, wedge_g, wedge_b);
                    
                    if wedge_index >= 0 {
                        print("Created wedge at index: ");
                        print(wedge_index);
                        print("\n");
                    }
                    
                    key_0_was_pressed = 1;
                }
            } else {
                key_0_was_pressed = 0;
            }
            
            // Ctrl+M (77 is 'M') - Combine selected cubes into mesh and save as .hdm
            let m_is_pressed: i32 = heidic_is_key_pressed(window, 77);
            let ctrl_is_down: i32 = heidic_ctrl_down(window);
            if m_is_pressed == 1 && ctrl_is_down == 1 {
                let selected_count: i32 = heidic_get_selection_count();
                if selected_count > 0 {
                    // Save to meshes directory (create if doesn't exist)
                    // For now, save to "meshes/combined_mesh.hdm" in current directory
                    let mesh_filepath: string = "meshes/combined_mesh.hdm";
                    let result: i32 = heidic_combine_selected_cubes_to_mesh(mesh_filepath);
                    if result == 1 {
                        print("Successfully combined selected cubes into mesh: ");
                        print(mesh_filepath);
                        print("\n");
                        // Optionally clear selection after combining
                        // heidic_clear_selection();
                    } else {
                        print("Failed to combine cubes into mesh\n");
                    }
                }
            }
        
        // Shift+S (83 is 'S') - Smooth selected cubes
        // Check shift state (reuse same logic as Shift+Enter)
        let s_is_pressed: i32 = heidic_is_key_pressed(window, 83);
        let s_shift_is_pressed: i32 = 0;
        let s_left_shift: i32 = heidic_is_key_pressed(window, 340);
        let s_right_shift: i32 = heidic_is_key_pressed(window, 344);
        if s_left_shift == 1 {
            s_shift_is_pressed = 1;
        }
        if s_right_shift == 1 {
            s_shift_is_pressed = 1;
        }
        
        if s_is_pressed == 1 && s_shift_is_pressed == 1 {
            if smooth_s_was_pressed == 0 {
                let selected_count: i32 = heidic_get_selection_count();
                if selected_count > 0 {
                    let result: i32 = heidic_smooth_selected_cubes();
                    if result == 1 {
                        print("Successfully smoothed selected cubes\n");
                    } else {
                        print("Failed to smooth cubes\n");
                    }
                } else {
                    print("No cubes selected for smoothing\n");
                }
                smooth_s_was_pressed = 1;
            }
        } else {
            smooth_s_was_pressed = 0;
        }
        
        // C key (67) - Combine selected cubes
        let c_is_pressed: i32 = heidic_is_key_pressed(window, 67);
        
        if c_is_pressed == 1 {
            if combine_c_was_pressed == 0 {
                // Check if we have any cubes selected
                let selection_count: i32 = heidic_get_selection_count();
                if selection_count > 0 {
                    print("C pressed - Combining selected cubes\n");
                    heidic_combine_selected_cubes();
                    print("Combination complete\n");
                } else {
                    // No selection, silently fail (do nothing)
                }
            }
            combine_c_was_pressed = 1;
        } else {
            combine_c_was_pressed = 0;
        }
        
        // Delete key (261) - Delete selected cube, light, or mesh
        let delete_is_pressed: i32 = heidic_is_key_pressed(window, 261);
        if delete_is_pressed == 1 {
            if delete_was_pressed == 0 {
                // Check for selected light first
                if has_light_selection == 1 && selected_light_id >= 0 {
                    heidic_delete_light(selected_light_id);
                    print("Deleted light at index ");
                    print(selected_light_id);
                    print("\n");
                    
                    // Clear selection after deletion
                    has_light_selection = 0;
                    selected_light_id = -1;
                } else {
                    // Check for selected mesh
                    if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
                        heidic_delete_mesh_instance(selected_mesh_instance_id);
                        print("Deleted mesh instance at index ");
                        print(selected_mesh_instance_id);
                        print("\n");
                        
                        // Clear selection after deletion
                        has_mesh_selection = 0;
                        selected_mesh_instance_id = -1;
                    } else {
                        // Check for selected cube (only if it's a created cube, not player)
                        if has_selection == 1 && selected_cube_index >= 2.0 {
                            // Convert float index to int (created cubes: index = vector_index + 2.0)
                            let cube_vector_index: i32 = heidic_float_to_int(selected_cube_index - 2.0);
                            heidic_delete_cube(cube_vector_index);
                            print("Deleted cube at index ");
                            print(cube_vector_index);
                            print("\n");
                            
                            // Clear selection after deletion
                            has_selection = 0;
                            selected_cube_index = -1.0;
                        }
                    }
                }
                delete_was_pressed = 1;
            }
        } else {
            delete_was_pressed = 0;
        }
        
        // Shift+Enter Toggle Logic - Switch between Fullscreen and Windowed
        // Enter = 257, Left Shift = 340, Right Shift = 344
        let enter_is_pressed: i32 = heidic_is_key_pressed(window, 257);
        let left_shift_is_pressed: i32 = heidic_is_key_pressed(window, 340);
        let right_shift_is_pressed: i32 = heidic_is_key_pressed(window, 344);
        let shift_is_pressed: i32 = 0;
        if left_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        if right_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        
        if enter_is_pressed == 1 && shift_is_pressed == 1 {
            if shift_enter_was_pressed == 0 {
                if video_mode == 1 {
                    video_mode = 0; // Switch to fullscreen
                    heidic_set_video_mode(0);
                } else {
                    video_mode = 1; // Switch to windowed
                    heidic_set_video_mode(1);
                }
                shift_enter_was_pressed = 1;
            }
        } else {
            shift_enter_was_pressed = 0;
        }
        
        // Calculate forward and right direction vectors based on Y rotation
        // Forward should follow the yellow line (Z-axis) direction
        // At 0: forward = (0, 0, -1) = negative Z (model's forward at start)
        let rot_y_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
        // Forward follows the rotated negative Z-axis (yellow line direction)
        // Try: forward = (-sin(angle), 0, -cos(angle))
        let forward_x: f32 = -heidic_sin(rot_y_rad);
        let forward_z: f32 = -heidic_cos(rot_y_rad);
        // Right = (cos(angle), 0, -sin(angle))
        let right_x: f32 = heidic_cos(rot_y_rad);
        let right_z: f32 = -heidic_sin(rot_y_rad);
        
        // WASD Movement Controls (relative to rotation)
        // W = 87: move forward (in direction player is facing)
        if heidic_is_key_pressed(window, 87) == 1 {
            player_pos.x = player_pos.x + forward_x * move_speed;
            player_pos.z = player_pos.z + forward_z * move_speed;
        }
        // S = 83: move backward (opposite of forward)
        if heidic_is_key_pressed(window, 83) == 1 {
            player_pos.x = player_pos.x - forward_x * move_speed;
            player_pos.z = player_pos.z - forward_z * move_speed;
        }
        // A = 65: move left (negative right direction)
        if heidic_is_key_pressed(window, 65) == 1 {
            player_pos.x = player_pos.x - right_x * move_speed;
            player_pos.z = player_pos.z - right_z * move_speed;
        }
        // D = 68: move right (positive right direction)
        if heidic_is_key_pressed(window, 68) == 1 {
            player_pos.x = player_pos.x + right_x * move_speed;
            player_pos.z = player_pos.z + right_z * move_speed;
        }
        
        // Left Shift = 340: Lower player (move down in Y)
        let left_shift_pressed: i32 = heidic_is_key_pressed(window, 340);
        if left_shift_pressed == 1 {
            player_pos.y = player_pos.y - move_speed;
        }
        // Spacebar = 32 (or 57): Raise player (move up in Y)
        let spacebar_pressed: i32 = heidic_is_key_pressed(window, 32);
        if spacebar_pressed == 0 {
            spacebar_pressed = heidic_is_key_pressed(window, 57);  // Fallback key code
        }
        if spacebar_pressed == 1 {
            player_pos.y = player_pos.y + move_speed;
        }
        
        // FPS Mode: Make camera follow player with offset
        // Add offset to player position (100 units above player = eye height)
        let offset: Vec3 = heidic_vec3(0.0, 100.0, 0.0);
        let offset_pos: Vec3 = heidic_vec3_add(player_pos, offset);
        
        // Copy offset position to camera position
        camera_pos = heidic_attach_camera_translation(offset_pos);
        // Copy player rotation to camera rotation
        camera_rot = heidic_attach_camera_rotation(player_rot);
        
        // Update legacy variables for drawing
        cube_x = player_pos.x;
        cube_y = player_pos.y;
        cube_z = player_pos.z;
        cube_rx = player_rot.x;
        cube_ry = player_rot.y;
        cube_rz = player_rot.z;
        
        heidic_begin_frame();
        // print("[HEIDIC DEBUG] After heidic_begin_frame()\n");  // Debug: uncomment when needed
        
        // Setup dockspace (enables docking for all windows)
        heidic_imgui_setup_dockspace();
        // print("[HEIDIC DEBUG] After heidic_imgui_setup_dockspace()\n");  // Debug: uncomment when needed
        
        // Main Menu Bar
        // print("[HEIDIC DEBUG] About to begin main menu bar\n");  // Debug: uncomment when needed
        if heidic_imgui_begin_main_menu_bar() == 1 {
            // print("[HEIDIC DEBUG] Inside main menu bar\n");  // Debug: uncomment when needed
            // print("[HEIDIC DEBUG] About to begin File menu\n");  // Debug: uncomment when needed
            if heidic_imgui_begin_menu("File") == 1 {
                // print("[HEIDIC DEBUG] Inside File menu\n");  // Debug: uncomment when needed
                // print("[HEIDIC DEBUG] About to check Save Level As menu item\n");  // Debug: uncomment when needed
                if heidic_imgui_menu_item("Save Level As...") == 1 {
                    // Show native save dialog
                    let save_result: i32 = heidic_show_save_dialog();
                    if save_result == 1 {
                        // Success - level saved via dialog
                    }
                }
                if heidic_imgui_menu_item("Open Level...") == 1 {
                    // Show native open dialog
                    let load_result: i32 = heidic_show_open_dialog();
                    if load_result == 1 {
                        // Success - level loaded via dialog
                    }
                }
                heidic_imgui_separator();
                if heidic_imgui_menu_item("Exit") == 1 {
                    heidic_set_window_should_close(window, 1);
                }
                heidic_imgui_end_menu();
                // print("[HEIDIC DEBUG] After File menu\n");  // Debug: uncomment when needed
            }
            // print("[HEIDIC DEBUG] About to begin Object menu\n");  // Debug: uncomment when needed
            if heidic_imgui_begin_menu("Object") == 1 {
                // print("[HEIDIC DEBUG] Inside Object menu\n");  // Debug: uncomment when needed
                if heidic_imgui_menu_item("Add Cube") == 1 {
                    // Create cube at origin (0, 0, 0) with default size
                    let default_cube_size: f32 = 200.0; // 2 meters
                    let new_cube_index: i32 = heidic_create_cube(0.0, 0.0, 0.0, default_cube_size, default_cube_size, default_cube_size);
                    // Select the newly created cube (indices start from 2.0 for created cubes)
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(new_cube_index) + 2.0;
                    has_selection = 1;
                    // Update selected cube properties for gizmo
                    selected_cube_x = 0.0;
                    selected_cube_y = 0.0;
                    selected_cube_z = 0.0;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                }
                if heidic_imgui_menu_item("Load Mesh") == 1 {
                    let mesh_id: i32 = heidic_show_open_mesh_dialog();
                    if mesh_id >= 0 {
                        print("Successfully loaded mesh with ID: ");
                        print(mesh_id);
                        print("\n");
                    } else {
                        print("Failed to load mesh or user cancelled\n");
                    }
                }
                // print("[HEIDIC DEBUG] About to end Object menu\n");  // Debug: uncomment when needed
                heidic_imgui_end_menu();
                // print("[HEIDIC DEBUG] After Object menu\n");  // Debug: uncomment when needed
            }
            // Window menu
            if heidic_imgui_begin_menu("Window") == 1 {
                // Toggle Codex Of Forms window
                if heidic_imgui_menu_item_toggle("Codex Of Forms", show_codex_window) == 1 {
                    show_codex_window = 1 - show_codex_window;
                }
                // Toggle Texture Swatches window
                if heidic_imgui_menu_item_toggle("Texture Swatches", show_texture_swatches_window) == 1 {
                    show_texture_swatches_window = 1 - show_texture_swatches_window;
                }
                // Toggle UV Editor window
                if heidic_imgui_menu_item_toggle("UV Editor", show_uv_editor_window) == 1 {
                    show_uv_editor_window = 1 - show_uv_editor_window;
                }
                // Toggle Performance Info window
                if heidic_imgui_menu_item_toggle("Performance Info", show_performance_info_window) == 1 {
                    show_performance_info_window = 1 - show_performance_info_window;
                }
                heidic_imgui_end_menu();
            }
            // print("[HEIDIC DEBUG] About to end main menu bar\n");  // Debug: uncomment when needed
            heidic_imgui_end_main_menu_bar();
            // print("[HEIDIC DEBUG] After ending main menu bar (HEIDIC)\n");  // Debug: uncomment when needed
        }
        // print("[HEIDIC DEBUG] After main menu bar block\n");  // Debug: uncomment when needed
        
        // Toolbar/Shelf - Fixed toolbar underneath menu bar
        if heidic_imgui_begin_toolbar() == 1 {
            // Slow speed toggle button (10x10 pixels)
            if heidic_imgui_button_sized("S", 10.0, 10.0) == 1 {
                slow_speed_mode = 1 - slow_speed_mode; // Toggle
            }
            // Update move speed based on mode
            if slow_speed_mode == 1 {
                move_speed = slow_speed;
            } else {
                move_speed = normal_speed;
            }
            heidic_imgui_end_toolbar();
        }
        
        // Update Camera with Vec3 values
        // FPS mode: use large far plane (100000 units = 1km) for better visibility
        heidic_update_camera_with_far(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z, 100000.0);
        // print("[HEIDIC DEBUG] After camera update block\n");  // Debug: uncomment when needed
        
        // Draw solid ground plane cube: 100m x 100m x 1m thick, top at y = 0
        // 100 meters = 10000 units, 1 meter = 100 units
        // Center at y = -50 units (-0.5m) so top is at y = 0
        // Ensure default white texture is loaded before drawing non-textured geometry
        // This prevents texture color from tinting the ground plane
        // print("[HEIDIC DEBUG] Before ground plane drawing\n");  // Debug: uncomment when needed
        heidic_load_texture_for_rendering("default.bmp");
        // print("[HEIDIC DEBUG] After heidic_load_texture_for_rendering\n");  // Debug: uncomment when needed
        heidic_draw_cube_grey(0.0, -50.0, 0.0, 0.0, 0.0, 0.0, 10000.0, 100.0, 10000.0);
        
        // Draw vertical side plane: 100m x 100m x 1m thick, orthogonal to floor
        // Positioned 50m out from center (at edge of floor) and 50m up (bottom at y=0, top at y=100m)
        // Center at x = 5000 units (50m), y = 5000 units (50m), z = 0
        // No rotation needed - already oriented correctly (in YZ plane, facing along X axis)
        heidic_draw_cube_grey(5000.0, 5000.0, 0.0, 0.0, 0.0, 0.0, 100.0, 10000.0, 10000.0);
        // print("[HEIDIC DEBUG] After heidic_draw_cube_grey\n");  // Debug: uncomment when needed
        
        // Draw Ground Plane grid (large grid at y=-300) - only if grid is visible
        if show_grid == 1 {
            heidic_draw_ground_plane(20000.0, 0.5, 0.5, 0.5); // 200 meters, grey color
        }
        // print("[HEIDIC DEBUG] After ground plane grid\n");  // Debug: uncomment when needed
        
        // Player cube is always invisible in FPS mode
        // (Drawing code removed - player_cube_visible is always INVISIBLE)
        // print("[HEIDIC DEBUG] After player cube drawing\n");  // Debug: uncomment when needed
        
        // Draw Origin Lines (1 meter = 100 cm = 100 units)
        // Player origin lines are invisible (only draw for reference cubes if needed)
        // heidic_draw_model_origin(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, 100.0);
        
        // Starting cubes removed - user can create cubes with Spacebar or Object menu
        
        // Draw Created Cubes (user-created via Spacebar) - Dynamic system
        // Batch cubes by texture: when texture changes, flush current batch and start new one
        // This ensures each cube gets the correct texture while maintaining efficient batching
        // print("[HEIDIC DEBUG] Before cube drawing loop\n");  // Debug: uncomment when needed
        let cube_draw_index: i32 = 0;
        let total_cubes: i32 = heidic_get_cube_total_count();
        // print("[HEIDIC DEBUG] Got total_cubes, starting loop\n");  // Debug: uncomment when needed
        let current_texture: string = "";
        let first_cube: i32 = 1;
        
        while cube_draw_index < total_cubes {
            // if cube_draw_index == 0 {
            //     print("[HEIDIC DEBUG] First iteration of cube loop\n");  // Debug: uncomment when needed
            // }
            if heidic_get_cube_active(cube_draw_index) == 1 {
                // if cube_draw_index == 0 {
                //     print("[HEIDIC DEBUG] First cube is active\n");  // Debug: uncomment when needed
                // }
                let cube_texture_name: string = heidic_get_cube_texture_name(cube_draw_index);
                // Use default texture if empty
                if cube_texture_name == "" {
                    cube_texture_name = "default.bmp";
                }
                
                // If texture changed, flush previous batch and start new one
                if first_cube == 0 && cube_texture_name != current_texture {
                    // Flush current batch (draw all cubes with current_texture)
                    heidic_flush_colored_cubes();
                    // Load new texture
                    heidic_load_texture_for_rendering(cube_texture_name);
                    current_texture = cube_texture_name;
                } else {
                    if first_cube == 1 {
                        // First cube - load its texture
                        heidic_load_texture_for_rendering(cube_texture_name);
                        current_texture = cube_texture_name;
                        first_cube = 0;
                    }
                }
                
                let cube_x: f32 = heidic_get_cube_x(cube_draw_index);
                let cube_y: f32 = heidic_get_cube_y(cube_draw_index);
                let cube_z: f32 = heidic_get_cube_z(cube_draw_index);
                let cube_sx: f32 = heidic_get_cube_sx(cube_draw_index);
                let cube_sy: f32 = heidic_get_cube_sy(cube_draw_index);
                let cube_sz: f32 = heidic_get_cube_sz(cube_draw_index);
                let cube_rx: f32 = heidic_get_cube_rx(cube_draw_index);
                let cube_ry: f32 = heidic_get_cube_ry(cube_draw_index);
                let cube_rz: f32 = heidic_get_cube_rz(cube_draw_index);
                
                // Draw cube with white color (1,1,1) so texture displays at full brightness without tinting
                heidic_draw_cube_colored(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx, cube_sy, cube_sz, 1.0, 1.0, 1.0);
                
                // Draw wireframe outline for selected cubes
                if heidic_is_cube_selected(cube_draw_index) == 1 {
                    // Draw wireframe outline (slightly larger than cube, white color)
                    heidic_draw_cube_wireframe(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx * 1.01, cube_sy * 1.01, cube_sz * 1.01, 1.0, 1.0, 1.0);
                }
            }
            cube_draw_index = cube_draw_index + 1;
        }
        // print("[HEIDIC DEBUG] After cube drawing loop\n");  // Debug: uncomment when needed
        
        // Flush any remaining batched cubes at the end (draw final texture group)
        heidic_flush_colored_cubes();
        // print("[HEIDIC DEBUG] After flushing colored cubes\n");  // Debug: uncomment when needed
        
        // Draw Created Wedges (user-created via '0' key)
        // print("[HEIDIC DEBUG] Before wedge drawing\n");  // Debug: uncomment when needed
        let wedge_total_count: i32 = heidic_get_wedge_total_count();
        // print("[HEIDIC DEBUG] Got wedge_total_count, starting wedge loop\n");  // Debug: uncomment when needed
        let wedge_draw_index: i32 = 0;
        let first_wedge: i32 = 1;
        let current_wedge_texture: string = "";
        
        while wedge_draw_index < wedge_total_count {
            if heidic_get_wedge_active(wedge_draw_index) == 1 {
                let wedge_texture_name: string = heidic_get_wedge_texture_name(wedge_draw_index);
                if wedge_texture_name == "" {
                    wedge_texture_name = "default.bmp";
                }
                
                if first_wedge == 0 && wedge_texture_name != current_wedge_texture {
                    heidic_flush_colored_cubes();
                    heidic_load_texture_for_rendering(wedge_texture_name);
                    current_wedge_texture = wedge_texture_name;
                } else {
                    if first_wedge == 1 {
                        heidic_load_texture_for_rendering(wedge_texture_name);
                        current_wedge_texture = wedge_texture_name;
                        first_wedge = 0;
                    }
                }
                
                let wedge_x: f32 = heidic_get_wedge_x(wedge_draw_index);
                let wedge_y: f32 = heidic_get_wedge_y(wedge_draw_index);
                let wedge_z: f32 = heidic_get_wedge_z(wedge_draw_index);
                let wedge_sx: f32 = heidic_get_wedge_sx(wedge_draw_index);
                let wedge_sy: f32 = heidic_get_wedge_sy(wedge_draw_index);
                let wedge_sz: f32 = heidic_get_wedge_sz(wedge_draw_index);
                let wedge_rx: f32 = heidic_get_wedge_rx(wedge_draw_index);
                let wedge_ry: f32 = heidic_get_wedge_ry(wedge_draw_index);
                let wedge_rz: f32 = heidic_get_wedge_rz(wedge_draw_index);
                
                // Draw wedge with white color (full texture brightness)
                heidic_draw_wedge_colored(wedge_x, wedge_y, wedge_z, wedge_rx, wedge_ry, wedge_rz, wedge_sx, wedge_sy, wedge_sz, 1.0, 1.0, 1.0);
            }
            wedge_draw_index = wedge_draw_index + 1;
        }
        // print("[HEIDIC DEBUG] After wedge drawing loop\n");  // Debug: uncomment when needed
        
        // Flush any remaining batched wedges
        heidic_flush_colored_cubes();
        // print("[HEIDIC DEBUG] After flushing wedges\n");  // Debug: uncomment when needed
        
        // Draw all loaded mesh instances (from .hdm files)
        // print("[HEIDIC DEBUG] Before mesh instance drawing\n");  // Debug: uncomment when needed
        let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
        // print("[HEIDIC DEBUG] Got mesh_instance_count\n");  // Debug: uncomment when needed
        if mesh_instance_count > 0 {
            // print("[HEIDIC DEBUG] mesh_instance_count > 0, entering mesh instance loop\n");  // Debug: uncomment when needed
            // Ensure default texture is loaded after drawing cubes (in case mesh has no texture)
            heidic_load_texture_for_rendering("default.bmp");
            
            let mesh_instance_index: i32 = 0;
            while mesh_instance_index < mesh_instance_count {
                if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                    // Get mesh instance data
                    let instance_mesh_id: i32 = heidic_get_mesh_instance_mesh_id(mesh_instance_index);
                    let instance_x: f32 = heidic_get_mesh_instance_x(mesh_instance_index);
                    let instance_y: f32 = heidic_get_mesh_instance_y(mesh_instance_index);
                    let instance_z: f32 = heidic_get_mesh_instance_z(mesh_instance_index);
                    
                    // Get mesh center, scale, and rotation
                    let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(mesh_instance_index);
                    let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(mesh_instance_index);
                    let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(mesh_instance_index);
                    let mesh_sx: f32 = heidic_get_mesh_instance_sx(mesh_instance_index);
                    let mesh_sy: f32 = heidic_get_mesh_instance_sy(mesh_instance_index);
                    let mesh_sz: f32 = heidic_get_mesh_instance_sz(mesh_instance_index);
                    let mesh_rx: f32 = heidic_get_mesh_instance_rx(mesh_instance_index);
                    let mesh_ry: f32 = heidic_get_mesh_instance_ry(mesh_instance_index);
                    let mesh_rz: f32 = heidic_get_mesh_instance_rz(mesh_instance_index);
                    
                    // Calculate actual world position (instance offset + original center)
                    let world_x: f32 = instance_x + mesh_center_x;
                    let world_y: f32 = instance_y + mesh_center_y;
                    let world_z: f32 = instance_z + mesh_center_z;
                    
                    // Draw mesh at world position with scale and rotation
                    // Note: Mesh vertices are in world space, so we need to scale around the mesh center
                    // to prevent translation when scaling
                    heidic_draw_mesh_scaled_with_center(instance_mesh_id, instance_x, instance_y, instance_z, mesh_rx, mesh_ry, mesh_rz, mesh_sx, mesh_sy, mesh_sz, mesh_center_x, mesh_center_y, mesh_center_z);
                    
                    // Draw wireframe bounding box for selected meshes
                    // NOTE: Bounding box is drawn with rotation to match the mesh transform
                    if heidic_is_mesh_selected(mesh_instance_index) == 1 {
                        // Get bounding box (relative to mesh center)
                        let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(mesh_instance_index);
                        let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(mesh_instance_index);
                        let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(mesh_instance_index);
                        let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(mesh_instance_index);
                        let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(mesh_instance_index);
                        let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(mesh_instance_index);
                        
                        // Scale bounding box by current scale
                        let scaled_min_x: f32 = bbox_min_x * mesh_sx;
                        let scaled_min_y: f32 = bbox_min_y * mesh_sy;
                        let scaled_min_z: f32 = bbox_min_z * mesh_sz;
                        let scaled_max_x: f32 = bbox_max_x * mesh_sx;
                        let scaled_max_y: f32 = bbox_max_y * mesh_sy;
                        let scaled_max_z: f32 = bbox_max_z * mesh_sz;
                        
                        // Calculate bounding box center and size (in world space)
                        // The mesh is drawn with instance_x, instance_y, instance_z as the base position
                        // and mesh_center_x, mesh_center_y, mesh_center_z as the center offset
                        // The final world position of the mesh center is: instance_pos + center
                        // BUT: The mesh drawing function applies transforms in order: T(pos) * T(center) * R * S * T(-center)
                        // So the actual world position of the center after all transforms is: instance_pos + center
                        // This is correct, so we use it for the bounding box too
                        let bbox_center_x: f32 = instance_x + mesh_center_x;
                        let bbox_center_y: f32 = instance_y + mesh_center_y;
                        let bbox_center_z: f32 = instance_z + mesh_center_z;
                        let bbox_size_x: f32 = scaled_max_x - scaled_min_x;
                        let bbox_size_y: f32 = scaled_max_y - scaled_min_y;
                        let bbox_size_z: f32 = scaled_max_z - scaled_min_z;
                        
                        // Draw wireframe bounding box (yellow) with rotation to match mesh
                        // Apply the same rotation as the mesh
                        heidic_draw_cube_wireframe(bbox_center_x, bbox_center_y, bbox_center_z, mesh_rx, mesh_ry, mesh_rz, 
                                                    bbox_size_x, bbox_size_y, bbox_size_z, 1.0, 1.0, 0.0);
                    }
                }
                mesh_instance_index = mesh_instance_index + 1;
            }
        } else {
            // print("[HEIDIC DEBUG] mesh_instance_count is 0, skipping mesh instance drawing\n");  // Debug: uncomment when needed
        }
        
        // Draw all directional lights as arrows
        heidic_draw_all_directional_lights();
        
        // print("[HEIDIC DEBUG] Before raycasting section\n");  // Debug: uncomment when needed
        // ============================================================================
        // RAYCASTING
        // ============================================================================
        // print("[HEIDIC DEBUG] Inside raycasting section, about to draw ray\n");  // Debug: uncomment when needed
        
        // Yellow debug line - draw from camera to 50km out along ray
        // This helps visualize where the ray is pointing
        heidic_draw_ray(window, 50000.0, 1.0, 1.0, 0.0);
        // print("[HEIDIC DEBUG] After heidic_draw_ray\n");  // Debug: uncomment when needed
        
        // Debug: Draw large red cube at ray hit point to visualize where ray intersects geometry
        // print("[HEIDIC DEBUG] About to enter raycast debug block\n");  // Debug: uncomment when needed
        // Preview raycast: only in build mode (mouse_mode == 0), use center ray for precise targeting
        if mouse_mode == 0 {
            // print("[HEIDIC DEBUG] Inside raycast debug block, getting ray origin/dir\n");  // Debug: uncomment when needed
            let debug_ray_origin: Vec3 = heidic_get_center_ray_origin(window);
            let debug_ray_dir: Vec3 = heidic_get_center_ray_dir(window);
            // print("[HEIDIC DEBUG] Got ray origin and dir, initializing variables\n");  // Debug: uncomment when needed
            let debug_hit_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
            let debug_found_hit: i32 = 0;
            let debug_closest_dist: f32 = 100000000000.0;
            let debug_hit_cube_x: f32 = 0.0;
            let debug_hit_cube_y: f32 = 0.0;
            let debug_hit_cube_z: f32 = 0.0;
            let debug_hit_cube_sx: f32 = 0.0;
            let debug_hit_cube_sy: f32 = 0.0;
            let debug_hit_cube_sz: f32 = 0.0;
            let debug_hit_face: i32 = -1; // -1 = no face, 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
            let debug_is_ground_plane: i32 = 0;
            let debug_is_wedge: i32 = 0; // 1 = hit object is a wedge, 0 = cube or other
            // print("[HEIDIC DEBUG] Initialized debug variables, about to test ground plane\n");  // Debug: uncomment when needed
            
            // FIRST: Test the big grey ground plane cube (100m x 100m x 1m, top at y = 0)
        // This is important geometry and needs to be pickable!
        let ground_cube_x: f32 = 0.0;
        let ground_cube_y: f32 = -50.0; // Center at -0.5m so top is at y=0
        let ground_cube_z: f32 = 0.0;
        let ground_cube_sx: f32 = 10000.0; // 100 meters
        let ground_cube_sy: f32 = 100.0;   // 1 meter thick
        let ground_cube_sz: f32 = 10000.0; // 100 meters
        
        // Also test the vertical side plane (100m x 100m x 1m, bottom at y=0, 50m out from center)
        let side_cube_x: f32 = 5000.0; // 50 meters out
        let side_cube_y: f32 = 5000.0; // 50 meters up (center, so bottom at y=0)
        let side_cube_z: f32 = 0.0;
        let side_cube_sx: f32 = 100.0;   // 1 meter thick (in X direction after rotation)
        let side_cube_sy: f32 = 10000.0; // 100 meters tall (in Y direction)
        let side_cube_sz: f32 = 10000.0; // 100 meters wide (in Z direction)
        
        // print("[HEIDIC DEBUG] About to raycast ground plane\n");  // Debug: uncomment when needed
        let ground_cube_hit: i32 = heidic_raycast_cube_hit_center(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
        // print("[HEIDIC DEBUG] After ground plane raycast\n");  // Debug: uncomment when needed
        if ground_cube_hit == 1 {
            // print("[HEIDIC DEBUG] Ground plane hit detected\n");  // Debug: uncomment when needed
            let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point_center(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
            let ground_cube_dist: f32 = (ground_cube_hit_point.x - debug_ray_origin.x) * (ground_cube_hit_point.x - debug_ray_origin.x) + (ground_cube_hit_point.y - debug_ray_origin.y) * (ground_cube_hit_point.y - debug_ray_origin.y) + (ground_cube_hit_point.z - debug_ray_origin.z) * (ground_cube_hit_point.z - debug_ray_origin.z);
            if ground_cube_dist < debug_closest_dist {
                debug_closest_dist = ground_cube_dist;
                debug_hit_pos = ground_cube_hit_point;
                debug_hit_cube_x = ground_cube_x;
                debug_hit_cube_y = ground_cube_y;
                debug_hit_cube_z = ground_cube_z;
                debug_hit_cube_sx = ground_cube_sx;
                debug_hit_cube_sy = ground_cube_sy;
                debug_hit_cube_sz = ground_cube_sz;
                debug_is_ground_plane = 1;
                debug_found_hit = 1;
            }
        }
        
        // Test vertical side plane
        let side_cube_hit: i32 = heidic_raycast_cube_hit_center(window, side_cube_x, side_cube_y, side_cube_z, side_cube_sx, side_cube_sy, side_cube_sz);
        if side_cube_hit == 1 {
            let side_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point_center(window, side_cube_x, side_cube_y, side_cube_z, side_cube_sx, side_cube_sy, side_cube_sz);
            let side_cube_dist: f32 = (side_cube_hit_point.x - debug_ray_origin.x) * (side_cube_hit_point.x - debug_ray_origin.x) + (side_cube_hit_point.y - debug_ray_origin.y) * (side_cube_hit_point.y - debug_ray_origin.y) + (side_cube_hit_point.z - debug_ray_origin.z) * (side_cube_hit_point.z - debug_ray_origin.z);
            if side_cube_dist < debug_closest_dist {
                debug_closest_dist = side_cube_dist;
                debug_hit_pos = side_cube_hit_point;
                debug_hit_cube_x = side_cube_x;
                debug_hit_cube_y = side_cube_y;
                debug_hit_cube_z = side_cube_z;
                debug_hit_cube_sx = side_cube_sx;
                debug_hit_cube_sy = side_cube_sy;
                debug_hit_cube_sz = side_cube_sz;
                debug_is_ground_plane = 0; // Side plane is not the ground plane
                debug_found_hit = 1;
            }
        }
        // print("[HEIDIC DEBUG] After ground plane raycast logic\n");  // Debug: uncomment when needed
        
        // Test all created cubes to find closest hit
        // print("[HEIDIC DEBUG] About to test cubes for raycast\n");  // Debug: uncomment when needed
        let debug_cube_index: i32 = 0;
        let debug_total_cubes: i32 = heidic_get_cube_total_count();
        // print("[HEIDIC DEBUG] Starting cube raycast loop\n");  // Debug: uncomment when needed
        while debug_cube_index < debug_total_cubes {
            if heidic_get_cube_active(debug_cube_index) == 1 {
                let debug_cube_x: f32 = heidic_get_cube_x(debug_cube_index);
                let debug_cube_y: f32 = heidic_get_cube_y(debug_cube_index);
                let debug_cube_z: f32 = heidic_get_cube_z(debug_cube_index);
                let debug_cube_sx: f32 = heidic_get_cube_sx(debug_cube_index);
                let debug_cube_sy: f32 = heidic_get_cube_sy(debug_cube_index);
                let debug_cube_sz: f32 = heidic_get_cube_sz(debug_cube_index);
                
                let debug_cube_hit: i32 = heidic_raycast_cube_hit_center(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                if debug_cube_hit == 1 {
                    let debug_hit_point: Vec3 = heidic_raycast_cube_hit_point_center(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                    let debug_dist: f32 = (debug_hit_point.x - debug_ray_origin.x) * (debug_hit_point.x - debug_ray_origin.x) + (debug_hit_point.y - debug_ray_origin.y) * (debug_hit_point.y - debug_ray_origin.y) + (debug_hit_point.z - debug_ray_origin.z) * (debug_hit_point.z - debug_ray_origin.z);
                    if debug_dist < debug_closest_dist {
                        debug_closest_dist = debug_dist;
                        debug_hit_pos = debug_hit_point;
                        debug_hit_cube_x = debug_cube_x;
                        debug_hit_cube_y = debug_cube_y;
                        debug_hit_cube_z = debug_cube_z;
                        debug_hit_cube_sx = debug_cube_sx;
                        debug_hit_cube_sy = debug_cube_sy;
                        debug_hit_cube_sz = debug_cube_sz;
                        debug_is_ground_plane = 0;
                        debug_found_hit = 1;
                    }
                }
            }
            debug_cube_index = debug_cube_index + 1;
        }
        // print("[HEIDIC DEBUG] After cube raycast loop\n");  // Debug: uncomment when needed
        
        // Test all created wedges to find closest hit
        // print("[HEIDIC DEBUG] About to test wedges for raycast\n");  // Debug: uncomment when needed
        let debug_wedge_index: i32 = 0;
        let debug_total_wedges: i32 = heidic_get_wedge_total_count();
        // print("[HEIDIC DEBUG] Starting wedge raycast loop\n");  // Debug: uncomment when needed
        while debug_wedge_index < debug_total_wedges {
            if heidic_get_wedge_active(debug_wedge_index) == 1 {
                let debug_wedge_x: f32 = heidic_get_wedge_x(debug_wedge_index);
                let debug_wedge_y: f32 = heidic_get_wedge_y(debug_wedge_index);
                let debug_wedge_z: f32 = heidic_get_wedge_z(debug_wedge_index);
                let debug_wedge_sx: f32 = heidic_get_wedge_sx(debug_wedge_index);
                let debug_wedge_sy: f32 = heidic_get_wedge_sy(debug_wedge_index);
                let debug_wedge_sz: f32 = heidic_get_wedge_sz(debug_wedge_index);
                
                let debug_wedge_hit: i32 = heidic_raycast_cube_hit_center(window, debug_wedge_x, debug_wedge_y, debug_wedge_z, debug_wedge_sx, debug_wedge_sy, debug_wedge_sz);
                if debug_wedge_hit == 1 {
                    let debug_wedge_hit_point: Vec3 = heidic_raycast_cube_hit_point_center(window, debug_wedge_x, debug_wedge_y, debug_wedge_z, debug_wedge_sx, debug_wedge_sy, debug_wedge_sz);
                    let debug_wedge_dist: f32 = (debug_wedge_hit_point.x - debug_ray_origin.x) * (debug_wedge_hit_point.x - debug_ray_origin.x) + (debug_wedge_hit_point.y - debug_ray_origin.y) * (debug_wedge_hit_point.y - debug_ray_origin.y) + (debug_wedge_hit_point.z - debug_ray_origin.z) * (debug_wedge_hit_point.z - debug_ray_origin.z);
                    if debug_wedge_dist < debug_closest_dist {
                        debug_closest_dist = debug_wedge_dist;
                        debug_hit_pos = debug_wedge_hit_point;
                        debug_hit_cube_x = debug_wedge_x;
                        debug_hit_cube_y = debug_wedge_y;
                        debug_hit_cube_z = debug_wedge_z;
                        debug_hit_cube_sx = debug_wedge_sx;
                        debug_hit_cube_sy = debug_wedge_sy;
                        debug_hit_cube_sz = debug_wedge_sz;
                        debug_is_ground_plane = 0;
                        debug_is_wedge = 1; // Mark as wedge
                        debug_found_hit = 1;
                    }
                }
            }
            debug_wedge_index = debug_wedge_index + 1;
        }
        // print("[HEIDIC DEBUG] After wedge raycast loop\n");  // Debug: uncomment when needed
        
        // Test all mesh instances to find closest hit (for debug cube positioning)
        // print("[HEIDIC DEBUG] About to test mesh instances for raycast\n");  // Debug: uncomment when needed
        let debug_mesh_instance_index: i32 = 0;
        let debug_total_mesh_instances: i32 = heidic_get_mesh_instance_total_count();
        while debug_mesh_instance_index < debug_total_mesh_instances {
            if heidic_get_mesh_instance_active(debug_mesh_instance_index) == 1 {
                let debug_mesh_hit: i32 = heidic_raycast_mesh_bbox_hit_center(window, debug_mesh_instance_index);
                if debug_mesh_hit == 1 {
                    let debug_mesh_hit_point: Vec3 = heidic_raycast_mesh_bbox_hit_point_center(window, debug_mesh_instance_index);
                    let debug_mesh_dist: f32 = (debug_mesh_hit_point.x - debug_ray_origin.x) * (debug_mesh_hit_point.x - debug_ray_origin.x) + (debug_mesh_hit_point.y - debug_ray_origin.y) * (debug_mesh_hit_point.y - debug_ray_origin.y) + (debug_mesh_hit_point.z - debug_ray_origin.z) * (debug_mesh_hit_point.z - debug_ray_origin.z);
                    if debug_mesh_dist < debug_closest_dist {
                        debug_closest_dist = debug_mesh_dist;
                        debug_hit_pos = debug_mesh_hit_point;
                        // For meshes, we don't have cube dimensions, so use a default size
                        debug_hit_cube_x = debug_mesh_hit_point.x;
                        debug_hit_cube_y = debug_mesh_hit_point.y;
                        debug_hit_cube_z = debug_mesh_hit_point.z;
                        debug_hit_cube_sx = 100.0;
                        debug_hit_cube_sy = 100.0;
                        debug_hit_cube_sz = 100.0;
                        debug_is_ground_plane = 0;
                        debug_found_hit = 1;
                    }
                }
            }
            debug_mesh_instance_index = debug_mesh_instance_index + 1;
        }
        // print("[HEIDIC DEBUG] After mesh instance raycast loop\n");  // Debug: uncomment when needed
        
        // Calculate where the cube would actually be placed (not just the hit point)
        // print("[HEIDIC DEBUG] About to calculate placement position\n");  // Debug: uncomment when needed
        // Declare this early so it can be used in all code paths
        let debug_placement_pos: Vec3 = debug_hit_pos; // Default: same as hit point
        let debug_default_cube_size: f32 = 100.0; // Same as cube creation size
        
        // If still no hit, place debug cube along the ray (5 meters out) so we can always see where the ray is pointing
        if debug_found_hit == 0 {
            debug_hit_pos = heidic_vec3_add(debug_ray_origin, heidic_vec3_mul_scalar(debug_ray_dir, 500.0));
            debug_placement_pos = debug_hit_pos; // No hit, so placement is same as hit point
            stored_preview_pos = debug_placement_pos;
            stored_preview_valid = 1;
        }
        
        // If we hit a cube or wedge, calculate the actual placement position
        if debug_found_hit == 1 && debug_is_ground_plane == 0 {
            // Calculate bounds
            let debug_cube_min_x: f32 = debug_hit_cube_x - debug_hit_cube_sx / 2.0;
            let debug_cube_max_x: f32 = debug_hit_cube_x + debug_hit_cube_sx / 2.0;
            let debug_cube_min_y: f32 = debug_hit_cube_y - debug_hit_cube_sy / 2.0;
            let debug_cube_max_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
            let debug_cube_min_z: f32 = debug_hit_cube_z - debug_hit_cube_sz / 2.0;
            let debug_cube_max_z: f32 = debug_hit_cube_z + debug_hit_cube_sz / 2.0;
            
            // Calculate distances from hit point to each face
            let debug_dist_to_left: f32 = debug_hit_pos.x - debug_cube_min_x;
            let debug_dist_to_right: f32 = debug_cube_max_x - debug_hit_pos.x;
            let debug_dist_to_bottom: f32 = debug_hit_pos.y - debug_cube_min_y;
            let debug_dist_to_top: f32 = debug_cube_max_y - debug_hit_pos.y;
            let debug_dist_to_back: f32 = debug_hit_pos.z - debug_cube_min_z;
            let debug_dist_to_front: f32 = debug_cube_max_z - debug_hit_pos.z;
            
            // Find the closest face (same logic as placement)
            // For both cubes and wedges, check all 6 faces of the bounding box
            // (Wedges are inscribed in a cube, so we treat them the same as cubes)
            let debug_min_dist: f32 = debug_dist_to_left;
            debug_hit_face = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
            
            // Check all faces (works for both cubes and wedges)
            if debug_dist_to_right < debug_min_dist {
                debug_min_dist = debug_dist_to_right;
                debug_hit_face = 1;
            }
            if debug_dist_to_bottom < debug_min_dist {
                debug_min_dist = debug_dist_to_bottom;
                debug_hit_face = 2;
            }
            if debug_dist_to_top < debug_min_dist {
                debug_min_dist = debug_dist_to_top;
                debug_hit_face = 3;
            }
            if debug_dist_to_back < debug_min_dist {
                debug_min_dist = debug_dist_to_back;
                debug_hit_face = 4;
            }
            if debug_dist_to_front < debug_min_dist {
                debug_min_dist = debug_dist_to_front;
                debug_hit_face = 5;
            }
            
            // Calculate placement position based on hit face (same logic as actual placement)
            if debug_hit_face == 0 {
                // Left face (negative X) - stack to the left
                debug_placement_pos.x = debug_cube_min_x - debug_default_cube_size / 2.0;
                debug_placement_pos.y = debug_hit_cube_y;
                debug_placement_pos.z = debug_hit_cube_z;
            } else {
                if debug_hit_face == 1 {
                    // Right face (positive X) - stack to the right
                    debug_placement_pos.x = debug_cube_max_x + debug_default_cube_size / 2.0;
                    debug_placement_pos.y = debug_hit_cube_y;
                    debug_placement_pos.z = debug_hit_cube_z;
                } else {
                    if debug_hit_face == 2 {
                        // Bottom face (negative Y) - stack below
                        debug_placement_pos.x = debug_hit_cube_x;
                        debug_placement_pos.y = debug_cube_min_y - debug_default_cube_size / 2.0;
                        debug_placement_pos.z = debug_hit_cube_z;
                    } else {
                        if debug_hit_face == 3 {
                            // Top face (positive Y) - stack on top
                            debug_placement_pos.x = debug_hit_cube_x;
                            debug_placement_pos.y = debug_cube_max_y + debug_default_cube_size / 2.0;
                            debug_placement_pos.z = debug_hit_cube_z;
                        } else {
                            if debug_hit_face == 4 {
                                // Back face (negative Z) - stack to the back
                                debug_placement_pos.x = debug_hit_cube_x;
                                debug_placement_pos.y = debug_hit_cube_y;
                                debug_placement_pos.z = debug_cube_min_z - debug_default_cube_size / 2.0;
                            } else {
                                // Front face (positive Z) - stack to the front
                                debug_placement_pos.x = debug_hit_cube_x;
                                debug_placement_pos.y = debug_hit_cube_y;
                                debug_placement_pos.z = debug_cube_max_z + debug_default_cube_size / 2.0;
                            }
                        }
                    }
                }
            }
        } else {
            if debug_found_hit == 1 && debug_is_ground_plane == 1 {
                // Ground plane: stack on top
                let hit_top_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
                debug_placement_pos.y = hit_top_y + debug_default_cube_size / 2.0;
                debug_placement_pos.x = debug_hit_pos.x;
                debug_placement_pos.z = debug_hit_pos.z;
            }
        }
        
        // Store the preview position for actual placement to use (update every frame)
        stored_preview_pos = debug_placement_pos;
        stored_preview_valid = 1; // Mark as valid
        
        // Draw preview wireframe at the actual placement position (where block will be placed)
        // Show cube wireframe in cube mode, wedge wireframe in wedge mode
        // Unit square (100 units = 1 meter) for better precision
        if build_mode == 0 {
            // Cube mode: draw red cube wireframe
            heidic_draw_cube_wireframe(debug_placement_pos.x, debug_placement_pos.y, debug_placement_pos.z, 0.0, 0.0, 0.0, 100.0, 100.0, 100.0, 1.0, 0.0, 0.0);
        } else {
            if build_mode == 1 {
                // Wedge mode: draw red wedge wireframe with rotation
            // Custom rotation values for each of the 12 positions
            let wedge_rot_x: f32 = 0.0;
            let wedge_rot_y: f32 = 0.0;
            let wedge_rot_z: f32 = 0.0;
            
            if wedge_preview_rotation == 0 {
                wedge_rot_x = 270.0;
                wedge_rot_y = 180.0;
                wedge_rot_z = 90.0;
            } else {
                if wedge_preview_rotation == 1 {
                    wedge_rot_x = 180.0;
                    wedge_rot_y = 90.0;
                    wedge_rot_z = 270.0;
                } else {
                    if wedge_preview_rotation == 2 {
                        wedge_rot_x = 90.0;
                        wedge_rot_y = 270.0;
                        wedge_rot_z = 180.0;
                    } else {
                        if wedge_preview_rotation == 3 {
                            wedge_rot_x = 180.0;
                            wedge_rot_y = 0.0;
                            wedge_rot_z = 270.0;
                        } else {
                            if wedge_preview_rotation == 4 {
                                wedge_rot_x = 180.0;
                                wedge_rot_y = 180.0;
                                wedge_rot_z = 90.0;
                            } else {
                                if wedge_preview_rotation == 5 {
                                    wedge_rot_x = 180.0;
                                    wedge_rot_y = 90.0;
                                    wedge_rot_z = 90.0;
                                } else {
                                    if wedge_preview_rotation == 6 {
                                        wedge_rot_x = 180.0;
                                        wedge_rot_y = 270.0;
                                        wedge_rot_z = 90.0;
                                    } else {
                                        if wedge_preview_rotation == 7 {
                                            wedge_rot_x = 180.0;
                                            wedge_rot_y = 0.0;
                                            wedge_rot_z = 90.0;
                                        } else {
                                            if wedge_preview_rotation == 8 {
                                                wedge_rot_x = 180.0;
                                                wedge_rot_y = 90.0;
                                                wedge_rot_z = 180.0;
                                            } else {
                                                if wedge_preview_rotation == 9 {
                                                    wedge_rot_x = 90.0;
                                                    wedge_rot_y = 270.0;
                                                    wedge_rot_z = 270.0;
                                                } else {
                                                    if wedge_preview_rotation == 10 {
                                                        wedge_rot_x = 90.0;
                                                        wedge_rot_y = 270.0;
                                                        wedge_rot_z = 90.0;
                                                    } else {
                                                        if wedge_preview_rotation == 11 {
                                                            wedge_rot_x = 180.0;
                                                            wedge_rot_y = 0.0;
                                                            wedge_rot_z = 180.0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
                // Update last rotation index after calculating (but before drawing)
                last_wedge_preview_rotation = wedge_preview_rotation;
                
                heidic_draw_wedge_wireframe(debug_placement_pos.x, debug_placement_pos.y, debug_placement_pos.z, wedge_rot_x, wedge_rot_y, wedge_rot_z, 100.0, 100.0, 100.0, 1.0, 0.0, 0.0);
            } else {
                if build_mode == 4 {
                    // Spot light mode: draw preview cone at placement position
                    // Use a distinct color (yellow) to differentiate from placed lights (white)
                    // Default: white light, range 200.0, direction down (0, -1, 0)
                    // Inner cone: 0.0 radians (0 degrees), Outer cone: 0.785 radians (45 degrees)
                    let preview_range: f32 = 200.0;  // Match default range for spot lights
                    let preview_dir_x: f32 = 0.0;
                    let preview_dir_y: f32 = -1.0;
                    let preview_dir_z: f32 = 0.0;
                    let preview_outer_cone: f32 = 0.785;  // 45 degrees (PI/4)
                    // Use yellow/cyan color for preview to distinguish from placed lights (white)
                    let preview_r: f32 = 1.0;
                    let preview_g: f32 = 1.0;
                    let preview_b: f32 = 0.0;  // Yellow preview cone
                    // Draw preview cone using the same function as actual lights
                    // Note: This draws a preview cone that follows the raycast position
                    heidic_draw_spot_light_cone(debug_placement_pos.x, debug_placement_pos.y, debug_placement_pos.z, preview_dir_x, preview_dir_y, preview_dir_z, preview_range, preview_outer_cone, preview_r, preview_g, preview_b);
                }
            }
        }
        
        // Green lattice preview removed - red wireframe preview is sufficient
        // print("[HEIDIC DEBUG] End of raycast debug block\n");  // Debug: uncomment when needed
        }  // End of if mouse_mode == 0 (build mode preview)
        
        // Draw crosshair in build mode (mouse_mode == 0)
        if mouse_mode == 0 {
            heidic_draw_crosshair(window, 20.0, 1.0, 1.0, 1.0);  // White crosshair, 20 pixel size
        }
        // print("[HEIDIC DEBUG] After closing raycast debug block, before input handling\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to start input handling\n");  // Debug: uncomment when needed
        
        // Mouse mode toggle: Left-click enables mouse (cursor visible, picking on), Right-click disables (cursor hidden, dolly/look on)
        // print("[HEIDIC DEBUG] About to get mouse button states\n");  // Debug: uncomment when needed
        let mouse_left_pressed: i32 = heidic_is_mouse_button_pressed(window, 0);
        // print("[HEIDIC DEBUG] Got mouse_left_pressed\n");  // Debug: uncomment when needed
        // mouse_right_pressed already declared above for block placement
        // print("[HEIDIC DEBUG] Got mouse_right_pressed\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to handle mouse mode toggle\n");  // Debug: uncomment when needed
        
        // Left-click: Switch to selection mode (mouse_mode = 1) - cursor visible, can select blocks and interact with UI
        // print("[HEIDIC DEBUG] About to check mouse_left_pressed\n");  // Debug: uncomment when needed
        if mouse_left_pressed == 1 {
            // print("[HEIDIC DEBUG] mouse_left_pressed is 1\n");  // Debug: uncomment when needed
            if mouse_mode_left_was_pressed == 0 {
                // print("[HEIDIC DEBUG] mouse_mode_left_was_pressed is 0, switching to selection mode\n");  // Debug: uncomment when needed
                mouse_mode = 1; // Switch to selection mode
                // print("[HEIDIC DEBUG] About to call heidic_set_cursor_mode\n");  // Debug: uncomment when needed
                heidic_set_cursor_mode(window, 0); // 0 = normal (visible cursor)
                // print("[HEIDIC DEBUG] After heidic_set_cursor_mode\n");  // Debug: uncomment when needed
                mouse_mode_left_was_pressed = 1;
            }
        } else {
            mouse_mode_left_was_pressed = 0;
        }
        // print("[HEIDIC DEBUG] After mouse_left_pressed handling\n");  // Debug: uncomment when needed
        
        // Right-click: Switch to build mode (mouse_mode = 0) - cursor captured, crosshair visible, can place blocks
        // Also handles block placement when in build mode
        // print("[HEIDIC DEBUG] About to check mouse_right_pressed\n");  // Debug: uncomment when needed
        if mouse_right_pressed == 1 {
            // print("[HEIDIC DEBUG] mouse_right_pressed is 1\n");  // Debug: uncomment when needed
            if mouse_mode_right_was_pressed == 0 {
                // print("[HEIDIC DEBUG] mouse_mode_right_was_pressed is 0, switching to build mode\n");  // Debug: uncomment when needed
                mouse_mode = 0; // Switch to build mode
                // Capture cursor in build mode for FPS mouse look
                heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                mouse_mode_right_was_pressed = 1;
            } else {
                // print("[HEIDIC DEBUG] mouse_mode_right_was_pressed is not 0, skipping\n");  // Debug: uncomment when needed
            }
        } else {
            // print("[HEIDIC DEBUG] mouse_right_pressed is not 1\n");  // Debug: uncomment when needed
            mouse_mode_right_was_pressed = 0;
        }
        
        // Ensure cursor is always captured in build mode (every frame check)
        if mouse_mode == 0 {
            heidic_set_cursor_mode(window, 2); // 2 = disabled (captured) for FPS mode
        }
        // print("[HEIDIC DEBUG] After mouse_right_pressed handling\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to continue after mouse mode handling\n");  // Debug: uncomment when needed
        
        // DEBUG: Print ray info on click
        // if mouse_left_pressed == 1 {
        //    if mouse_left_was_pressed == 0 {
        //        heidic_debug_print_ray(window);
        //    }
        // }
        
        // Check gizmo interaction FIRST (before selection processing)
        // print("[HEIDIC DEBUG] About to check gizmo interaction\n");  // Debug: uncomment when needed
        // This prevents deselection when clicking on gizmos
        // print("[HEIDIC DEBUG] Initializing gizmo_clicked\n");  // Debug: uncomment when needed
        let gizmo_clicked: i32 = 0;
        // print("[HEIDIC DEBUG] After initializing gizmo_clicked\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to check gizmo interaction conditions\n");  // Debug: uncomment when needed
        if mouse_mode == 1 && mouse_left_pressed == 1 && has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
            // print("[HEIDIC DEBUG] Gizmo interaction conditions met, entering block\n");  // Debug: uncomment when needed
            // A mesh is selected - check if gizmo would be clicked
            let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(selected_mesh_instance_id);
            let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(selected_mesh_instance_id);
            let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(selected_mesh_instance_id);
            let gizmo_x: f32 = selected_mesh_x + mesh_center_x;
            let gizmo_y: f32 = selected_mesh_y + mesh_center_y;
            let gizmo_z: f32 = selected_mesh_z + mesh_center_z;
            let current_scale: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
            
            // Check if translation gizmo would be clicked (by calling it, but we'll check interaction state)
            // We need to call it to update its internal state, but we'll check if it becomes active
            let temp_pos: Vec3 = heidic_gizmo_translate(window, gizmo_x, gizmo_y, gizmo_z);
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Check if scale gizmo would be clicked
            let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(selected_mesh_instance_id);
            let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(selected_mesh_instance_id);
            let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(selected_mesh_instance_id);
            let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(selected_mesh_instance_id);
            let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(selected_mesh_instance_id);
            let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(selected_mesh_instance_id);
            let temp_scale: f32 = heidic_gizmo_scale(window, gizmo_x, gizmo_y, gizmo_z,
                                                     bbox_min_x, bbox_min_y, bbox_min_z,
                                                     bbox_max_x, bbox_max_y, bbox_max_z,
                                                     current_scale);
            let scale_interacting: i32 = heidic_gizmo_scale_is_interacting();
            
            if translate_interacting == 1 || scale_interacting == 1 {
                gizmo_clicked = 1;
            }
        } else {
            // print("[HEIDIC DEBUG] Gizmo interaction conditions not met\n");  // Debug: uncomment when needed
        }
        // print("[HEIDIC DEBUG] After gizmo interaction check\n");  // Debug: uncomment when needed
        
        // Selection: Click to select cubes - test ALL cubes
        // Only allow selection when mouse_mode is enabled (selection mode)
        // print("[HEIDIC DEBUG] About to check selection conditions\n");  // Debug: uncomment when needed
        if mouse_mode == 1 && mouse_left_pressed == 1 {
            // print("[HEIDIC DEBUG] Selection conditions met, entering block\n");  // Debug: uncomment when needed
            // Check if Ctrl is pressed for multi-select
            let ctrl_left_pressed: i32 = heidic_is_key_pressed(window, 341);
            let ctrl_right_pressed: i32 = heidic_is_key_pressed(window, 345);
            let ctrl_pressed: i32 = 0;
            if ctrl_left_pressed == 1 || ctrl_right_pressed == 1 {
                ctrl_pressed = 1;
            }
            
            // Only check gizmo interaction if we're NOT doing a fresh click
            // This allows selection even if gizmo axes are being hovered
            let interacting: i32 = 0;
            let scale_interacting: i32 = 0;
            if mouse_left_was_pressed == 1 {
                // Already was pressed - check if gizmo is actively being dragged
                interacting = heidic_gizmo_is_interacting();
                scale_interacting = heidic_gizmo_scale_is_interacting();
            }
            
            // Skip selection processing if gizmo was clicked
            if gizmo_clicked == 0 && (interacting == 0 && scale_interacting == 0) {
                if mouse_left_was_pressed == 0 {
                    // Just clicked - test raycast against all cubes and find closest hit
                    // Initialize closest_dist to a very large number (squared distance)
                    // 100,000,000,000.0 is roughly 316,000 units (3.16 km) distance
                    let closest_dist: f32 = 100000000000.0;
                    let hit_cube_index: i32 = -1;
                    
                    // Player cube is NOT selectable (it's invisible in walk mode and shouldn't interfere)
                    // Skip player cube selection test
                    
                    // Test Created Cubes (Dynamic system - indices start at 2.0)
                    let cube_test_index: i32 = 0;
                    let total_cubes_test: i32 = heidic_get_cube_total_count();
                    while cube_test_index < total_cubes_test {
                        if heidic_get_cube_active(cube_test_index) == 1 {
                            let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                            let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                            let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                            let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                            let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                            let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                            
                            let created_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            if created_hit == 1 {
                                let hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                                let dist: f32 = (hit_point.x - ray_origin.x) * (hit_point.x - ray_origin.x) + (hit_point.y - ray_origin.y) * (hit_point.y - ray_origin.y) + (hit_point.z - ray_origin.z) * (hit_point.z - ray_origin.z);
                                if dist < closest_dist {
                                    closest_dist = dist;
                                    hit_cube_index = cube_test_index;
                                }
                            }
                        }
                        cube_test_index = cube_test_index + 1;
                    }
                    
                    // Test Wedges (similar to cubes)
                    let wedge_test_index: i32 = 0;
                    let total_wedges_test: i32 = heidic_get_wedge_total_count();
                    let hit_wedge_index: i32 = -1;
                    while wedge_test_index < total_wedges_test {
                        if heidic_get_wedge_active(wedge_test_index) == 1 {
                            let test_wedge_x: f32 = heidic_get_wedge_x(wedge_test_index);
                            let test_wedge_y: f32 = heidic_get_wedge_y(wedge_test_index);
                            let test_wedge_z: f32 = heidic_get_wedge_z(wedge_test_index);
                            let test_wedge_sx: f32 = heidic_get_wedge_sx(wedge_test_index);
                            let test_wedge_sy: f32 = heidic_get_wedge_sy(wedge_test_index);
                            let test_wedge_sz: f32 = heidic_get_wedge_sz(wedge_test_index);
                            
                            // Use cube raycast (wedges use bounding box for raycast)
                            let wedge_hit: i32 = heidic_raycast_cube_hit(window, test_wedge_x, test_wedge_y, test_wedge_z, test_wedge_sx, test_wedge_sy, test_wedge_sz);
                            if wedge_hit == 1 {
                                let hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_wedge_x, test_wedge_y, test_wedge_z, test_wedge_sx, test_wedge_sy, test_wedge_sz);
                                let dist: f32 = (hit_point.x - ray_origin.x) * (hit_point.x - ray_origin.x) + (hit_point.y - ray_origin.y) * (hit_point.y - ray_origin.y) + (hit_point.z - ray_origin.z) * (hit_point.z - ray_origin.z);
                                if dist < closest_dist {
                                    closest_dist = dist;
                                    hit_wedge_index = wedge_test_index;
                                    hit_cube_index = -1; // Clear cube hit if wedge is closer
                                }
                            }
                        }
                        wedge_test_index = wedge_test_index + 1;
                    }
                    
                    // Handle selection based on Ctrl state
                    if hit_wedge_index >= 0 {
                        // Wedge was clicked - select it
                        heidic_clear_selection();
                        heidic_clear_mesh_selection();
                        selected_wedge_index = hit_wedge_index;
                        selected_wedge_x = heidic_get_wedge_x(hit_wedge_index);
                        selected_wedge_y = heidic_get_wedge_y(hit_wedge_index);
                        selected_wedge_z = heidic_get_wedge_z(hit_wedge_index);
                        selected_wedge_sx = heidic_get_wedge_sx(hit_wedge_index);
                        selected_wedge_sy = heidic_get_wedge_sy(hit_wedge_index);
                        selected_wedge_sz = heidic_get_wedge_sz(hit_wedge_index);
                        has_wedge_selection = 1;
                        has_selection = 0;  // Clear cube selection
                        has_mesh_selection = 0;  // Clear mesh selection
                        selected_cube_index = -1.0;
                        selected_mesh_instance_id = -1;
                    } else {
                        if hit_cube_index >= 0 {
                            if ctrl_pressed == 1 {
                            // Ctrl+Click: Toggle multi-select
                            heidic_toggle_selection(hit_cube_index);
                        } else {
                            // Regular click: Clear selection and select only this cube
                            heidic_clear_selection();
                            heidic_add_to_selection(hit_cube_index);
                        }
                        
                        // Update single selection state for gizmo compatibility
                        let cube_index_f: f32 = heidic_int_to_float(hit_cube_index);
                        selected_cube_index = cube_index_f + 2.0;
                        selected_cube_x = heidic_get_cube_x(hit_cube_index);
                        selected_cube_y = heidic_get_cube_y(hit_cube_index);
                        selected_cube_z = heidic_get_cube_z(hit_cube_index);
                        selected_cube_sx = heidic_get_cube_sx(hit_cube_index);
                        selected_cube_sy = heidic_get_cube_sy(hit_cube_index);
                        selected_cube_sz = heidic_get_cube_sz(hit_cube_index);
                        has_selection = 1;
                        
                        // Initialize dolly orbit state for new selection
                        let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                        let current_cam_pos: Vec3 = camera_pos;
                        let calculated_distance: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                        
                        // Use calculated distance if reasonable, otherwise use default
                        if calculated_distance > 10.0 && calculated_distance < 100000.0 {
                            dolly_orbit_distance = calculated_distance;
                        } else {
                            dolly_orbit_distance = 2000.0; // Default: 20 meters
                        }
                        dolly_orbit_azimuth = 0.0;
                        dolly_orbit_elevation = 45.0;
                        }
                    }
                    
                    mouse_left_was_pressed = 1;
                }
            } else {
                // Clicked on nothing - clear selection if not Ctrl+Click, not clicking on gizmo, and not clicking on ImGui
                let imgui_wants_mouse: i32 = heidic_imgui_wants_mouse();
                if ctrl_pressed == 0 && gizmo_clicked == 0 && imgui_wants_mouse == 0 {
                    heidic_clear_selection();
                    has_selection = 0;
                    selected_cube_index = -1.0;
                    
                    // Also clear mesh and wedge selection (only if not clicking on gizmo or ImGui)
                    heidic_clear_mesh_selection();
                    has_mesh_selection = 0;
                    selected_mesh_instance_id = -1;
                    has_wedge_selection = 0;
                    selected_wedge_index = -1;
                }
            }
        } else {
            mouse_left_was_pressed = 0;
        }
        // print("[HEIDIC DEBUG] After mouse click handling\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to close block_input check\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] Right before closing brace of block_input\n");  // Debug: uncomment when needed
        
        
        }  // End of block_input check
        // print("[HEIDIC DEBUG] IMMEDIATELY after closing brace\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] After block_input check closes\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to show selection and gizmo\n");  // Debug: uncomment when needed
        
        // Show selection and Gizmo (always show, even when editing)
        // print("[HEIDIC DEBUG] About to check has_selection\n");  // Debug: uncomment when needed
        if has_selection == 1 {
            // print("[HEIDIC DEBUG] has_selection is 1, entering block\n");  // Debug: uncomment when needed
            // Draw wireframe overlay (black)
            heidic_draw_cube_wireframe(selected_cube_x, selected_cube_y, selected_cube_z, 0.0, 0.0, 0.0, selected_cube_sx * 1.01, selected_cube_sy * 1.01, selected_cube_sz * 1.01, 0.0, 0.0, 0.0);
            
            // Gizmo: Move selected object
            // print("[HEIDIC DEBUG] About to call heidic_gizmo_translate\n");  // Debug: uncomment when needed
            let new_pos: Vec3 = heidic_gizmo_translate(window, selected_cube_x, selected_cube_y, selected_cube_z);
            // print("[HEIDIC DEBUG] After heidic_gizmo_translate\n");  // Debug: uncomment when needed
            
            // Update selected position (the ghost)
            selected_cube_x = new_pos.x;
            selected_cube_y = new_pos.y;
            selected_cube_z = new_pos.z;
            
            // Player cube is not selectable, so only update created cubes
            // If moving Created Cubes (selected_cube_index >= 2.0)
            // Map: selected_cube_index 2.0 -> cube index 0, 3.0 -> 1, etc.
            if selected_cube_index >= 2.0 {
                let cube_storage_index: f32 = selected_cube_index - 2.0;
                heidic_set_cube_pos_f(cube_storage_index, selected_cube_x, selected_cube_y, selected_cube_z);
            }
        }
        // print("[HEIDIC DEBUG] After has_selection check\n");  // Debug: uncomment when needed
        
        // Show mesh selection and Gizmo
        // print("[HEIDIC DEBUG] About to check mesh selection\n");  // Debug: uncomment when needed
        if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
            // print("[HEIDIC DEBUG] Mesh selection conditions met\n");  // Debug: uncomment when needed
            // Refresh cached position values from instance (in case they were updated via input fields)
            selected_mesh_x = heidic_get_mesh_instance_x(selected_mesh_instance_id);
            selected_mesh_y = heidic_get_mesh_instance_y(selected_mesh_instance_id);
            selected_mesh_z = heidic_get_mesh_instance_z(selected_mesh_instance_id);
            
            // Get mesh center and bounding box for gizmo positioning
            let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(selected_mesh_instance_id);
            let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(selected_mesh_instance_id);
            let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(selected_mesh_instance_id);
            
            // Get current scale
            let current_scale: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
            
            // Calculate world position of mesh center (instance offset + original center)
            let gizmo_x: f32 = selected_mesh_x + mesh_center_x;
            let gizmo_y: f32 = selected_mesh_y + mesh_center_y;
            let gizmo_z: f32 = selected_mesh_z + mesh_center_z;
            
            // Check if scale gizmo is being used (prevents translation when scaling)
            let scale_interacting: i32 = heidic_gizmo_scale_is_interacting();
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Scale gizmo: Scale selected mesh (using bounding box corners)
            // Get bounding box from instance (relative to mesh center)
            let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(selected_mesh_instance_id);
            let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(selected_mesh_instance_id);
            let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(selected_mesh_instance_id);
            let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(selected_mesh_instance_id);
            let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(selected_mesh_instance_id);
            let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(selected_mesh_instance_id);
            
            let new_scale: f32 = heidic_gizmo_scale(window, gizmo_x, gizmo_y, gizmo_z,
                                                     bbox_min_x, bbox_min_y, bbox_min_z,
                                                     bbox_max_x, bbox_max_y, bbox_max_z,
                                                     current_scale);
            
            // Update scale if it changed
            if new_scale != current_scale {
                heidic_set_mesh_instance_scale(selected_mesh_instance_id, new_scale, new_scale, new_scale);
            }
            
            // Translation gizmo: Only update if scale gizmo is not active
            if scale_interacting == 0 {
                // Translation gizmo: Move selected mesh (positioned at mesh center)
                let new_gizmo_pos: Vec3 = heidic_gizmo_translate(window, gizmo_x, gizmo_y, gizmo_z);
                
                // Only update position if translation gizmo is actually being dragged
                if translate_interacting == 1 {
                    // Calculate new instance offset (gizmo position - mesh center)
                    let new_instance_x: f32 = new_gizmo_pos.x - mesh_center_x;
                    let new_instance_y: f32 = new_gizmo_pos.y - mesh_center_y;
                    let new_instance_z: f32 = new_gizmo_pos.z - mesh_center_z;
                    
                    // Update selected mesh position
                    selected_mesh_x = new_instance_x;
                    selected_mesh_y = new_instance_y;
                    selected_mesh_z = new_instance_z;
                    
                    // Update mesh instance position
                    heidic_set_mesh_instance_pos(selected_mesh_instance_id, selected_mesh_x, selected_mesh_y, selected_mesh_z);
                }
            }
        }
        
        // Show light selection and Gizmo (position only, no scale/rotation)
        if has_light_selection == 1 && selected_light_id >= 0 {
            // Refresh cached position values from light (in case they were updated via input fields)
            selected_light_x = heidic_get_directional_light_x(selected_light_id);
            selected_light_y = heidic_get_directional_light_y(selected_light_id);
            selected_light_z = heidic_get_directional_light_z(selected_light_id);
            
            // Translation gizmo: Move selected light (always call to draw gizmo, even when not interacting)
            let new_light_pos: Vec3 = heidic_gizmo_translate(window, selected_light_x, selected_light_y, selected_light_z);
            
            // Check if gizmo is being interacted with
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Update position if gizmo moved (always update, not just when dragging)
            // This ensures the light position stays in sync with the gizmo
            if new_light_pos.x != selected_light_x || new_light_pos.y != selected_light_y || new_light_pos.z != selected_light_z {
                // Update selected light position
                selected_light_x = new_light_pos.x;
                selected_light_y = new_light_pos.y;
                selected_light_z = new_light_pos.z;
                
                // Update light position (only if actually interacting to avoid constant updates)
                if translate_interacting == 1 {
                    heidic_set_directional_light_pos(selected_light_id, selected_light_x, selected_light_y, selected_light_z);
                }
            }
        }
        // print("[HEIDIC DEBUG] End of raycasting section\n");  // Debug: uncomment when needed
        
        // Dispatch HEIDIC functions for all mesh instances
        let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
        let mesh_instance_index: i32 = 0;
        while mesh_instance_index < mesh_instance_count {
            if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                let function_name: string = heidic_get_mesh_instance_heidic_function(mesh_instance_index);
                if function_name != "" {
                    // Dispatch to the appropriate function based on function name
                    if function_name == "rotate_me" {
                        // Call rotate_me function for this mesh instance
                        rotate_me(mesh_instance_index);
                    }
                    // Add more function dispatches here as needed
                }
            }
            mesh_instance_index = mesh_instance_index + 1;
        }
        
        // print("[HEIDIC DEBUG] Before Codex Of Forms check (after all drawing)\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to render ImGui windows\n");  // Debug: uncomment when needed
        // Codex Of Forms - Show combinations and uncombined cubes
        if show_debug == 1 {
            // print("[HEIDIC DEBUG] About to begin Codex Of Forms window\n");  // Debug: uncomment when needed
            // Codex Of Forms window
            if show_codex_window == 1 {
                if heidic_imgui_begin("Codex Of Forms") == 0 {
                    // Window was closed (X button clicked)
                    show_codex_window = 0;
                } else {
                // print("[HEIDIC DEBUG] Inside Codex Of Forms window\n");  // Debug: uncomment when needed
                let combination_count: i32 = heidic_get_combination_count();
                let total_cube_count: i32 = heidic_get_cube_total_count();
                
                // Global cube display index (sequential across all cubes)
                let global_cube_display_index: i32 = 1;
                
                // First, show all combinations with expand/collapse
                let combo_id: i32 = 0;
                while combo_id < combination_count {
                    // Push unique ID for this combination to avoid ID conflicts
                    heidic_imgui_push_id(combo_id);
                    
                    // Check if we're editing this combination
                    let editing_id: i32 = heidic_get_editing_combination_id();
                    let is_editing_this: i32 = 0;
                    if editing_id == combo_id {
                        is_editing_this = 1;
                    }
                    
                    // Get combination name (e.g., "combination_001")
                    let combo_name: string = heidic_format_combination_name(combo_id);
                    
                    // Show expand/collapse button (with unique ID)
                    let is_expanded: i32 = heidic_is_combination_expanded(combo_id);
                    let expand_button_text: string = "+";
                    if is_expanded == 1 {
                        expand_button_text = "-";
                    }
                    if heidic_imgui_button(expand_button_text) == 1 {
                        heidic_toggle_combination_expanded(combo_id);
                    }
                    heidic_imgui_same_line();
                    
                    // Always show input field next to combination name (no click needed)
                    // This function handles the buffer internally and returns 1 when Enter is pressed
                    let enter_pressed: i32 = heidic_imgui_input_text_combination_simple(combo_id);
                    // Enter pressed is handled inside the function (saves automatically)
                    
                    // If expanded, show cubes in this combination
                    if is_expanded == 1 {
                        let cube_index: i32 = 0;
                        
                        while cube_index < total_cube_count {
                            if heidic_get_cube_active(cube_index) == 1 {
                                if heidic_get_cube_combination_id(cube_index) == combo_id {
                                    // Push unique ID for this cube
                                    heidic_imgui_push_id(cube_index);
                                    
                                    // This cube belongs to this combination
                                    // Use global sequential numbering
                                    let cube_name: string = heidic_format_cube_name_with_index(global_cube_display_index);
                                    
                                    // Make cube name clickable to select it
                                    // Check if Ctrl is pressed for multi-select
                                    let ctrl_pressed: i32 = heidic_ctrl_down(window);
                                    let is_selected: i32 = heidic_is_cube_selected(cube_index);
                                    
                                    // Show selected cubes in bold (yellow), unselected in red and clickable
                                    if is_selected == 1 {
                                        // Selected: show in bold (yellow) but still make it clickable for deselection
                                        if heidic_imgui_selectable_colored(cube_name, 1.0, 1.0, 0.0, 1.0) == 1 {
                                            // Clicked on selected cube
                                            if ctrl_pressed == 1 {
                                                // Ctrl+Click: deselect this cube (toggle)
                                                heidic_remove_from_selection(cube_index);
                                                // Update single selection state if this was the only selected cube
                                                let selection_count: i32 = heidic_get_selection_count();
                                                if selection_count == 0 {
                                                    has_selection = 0;
                                                    selected_cube_index = -1.0;
                                                } else {
                                                    // Find first remaining selected cube by iterating
                                                    let find_index: i32 = 0;
                                                    let total_cubes_find: i32 = heidic_get_cube_total_count();
                                                    let found_first: i32 = 0;
                                                    while find_index < total_cubes_find && found_first == 0 {
                                                        if heidic_get_cube_active(find_index) == 1 {
                                                            if heidic_is_cube_selected(find_index) == 1 {
                                                                let cube_index_f: f32 = heidic_int_to_float(find_index);
                                                                selected_cube_index = cube_index_f + 2.0;
                                                                selected_cube_x = heidic_get_cube_x(find_index);
                                                                selected_cube_y = heidic_get_cube_y(find_index);
                                                                selected_cube_z = heidic_get_cube_z(find_index);
                                                                selected_cube_sx = heidic_get_cube_sx(find_index);
                                                                selected_cube_sy = heidic_get_cube_sy(find_index);
                                                                selected_cube_sz = heidic_get_cube_sz(find_index);
                                                                has_selection = 1;
                                                                found_first = 1;
                                                            }
                                                        }
                                                        find_index = find_index + 1;
                                                    }
                                                }
                                            } else {
                                                // Regular click on selected cube: do nothing (keep selection)
                                            }
                                        }
                                    } else {
                                        // Not selected: show in red and make clickable
                                        if heidic_imgui_selectable_colored(cube_name, 1.0, 0.0, 0.0, 1.0) == 1 {
                                            // Clicked: select this cube
                                            if ctrl_pressed == 1 {
                                                // Ctrl+Click: add to selection (multi-select)
                                                heidic_add_to_selection(cube_index);
                                            } else {
                                                // Regular click: clear others and select only this one
                                                heidic_clear_selection();
                                                heidic_add_to_selection(cube_index);
                                            }
                                            
                                            // Update single selection state for gizmo (use this cube as primary)
                                            let cube_index_f: f32 = heidic_int_to_float(cube_index);
                                            selected_cube_index = cube_index_f + 2.0;
                                            selected_cube_x = heidic_get_cube_x(cube_index);
                                            selected_cube_y = heidic_get_cube_y(cube_index);
                                            selected_cube_z = heidic_get_cube_z(cube_index);
                                            selected_cube_sx = heidic_get_cube_sx(cube_index);
                                            selected_cube_sy = heidic_get_cube_sy(cube_index);
                                            selected_cube_sz = heidic_get_cube_sz(cube_index);
                                            has_selection = 1;
                                        }
                                    }
                                    
                                    heidic_imgui_pop_id();
                                    global_cube_display_index = global_cube_display_index + 1;
                                }
                            }
                            cube_index = cube_index + 1;
                        }
                    } else {
                        // Even if collapsed, we need to count the cubes for global numbering
                        let cube_index: i32 = 0;
                        while cube_index < total_cube_count {
                            if heidic_get_cube_active(cube_index) == 1 {
                                if heidic_get_cube_combination_id(cube_index) == combo_id {
                                    global_cube_display_index = global_cube_display_index + 1;
                                }
                            }
                            cube_index = cube_index + 1;
                        }
                    }
                    
                    // Pop combination ID
                    heidic_imgui_pop_id();
                    combo_id = combo_id + 1;
                }
                
                // Then, show uncombined cubes (cubes with combination_id == -1)
                let cube_index: i32 = 0;
                
                while cube_index < total_cube_count {
                    if heidic_get_cube_active(cube_index) == 1 {
                        if heidic_get_cube_combination_id(cube_index) == -1 {
                            // Push unique ID for this cube
                            heidic_imgui_push_id(cube_index);
                            
                            // This cube is not in any combination
                            let cube_name: string = heidic_format_cube_name_with_index(global_cube_display_index);
                            
                            // Make cube name clickable to select it
                            // Check if Ctrl is pressed for multi-select
                            let ctrl_pressed: i32 = heidic_ctrl_down(window);
                            let is_selected: i32 = heidic_is_cube_selected(cube_index);
                            
                            if is_selected == 1 {
                                // Selected: show in yellow and make clickable for deselection
                                if heidic_imgui_selectable_colored(cube_name, 1.0, 1.0, 0.0, 1.0) == 1 {
                                    // Clicked on selected cube
                                        if ctrl_pressed == 1 {
                                            // Ctrl+Click: deselect this cube (toggle)
                                            heidic_remove_from_selection(cube_index);
                                            // Update single selection state if this was the only selected cube
                                            let selection_count: i32 = heidic_get_selection_count();
                                            if selection_count == 0 {
                                                has_selection = 0;
                                                selected_cube_index = -1.0;
                                            } else {
                                                // Find first remaining selected cube by iterating
                                                let find_index: i32 = 0;
                                                let total_cubes_find: i32 = heidic_get_cube_total_count();
                                                let found_first: i32 = 0;
                                                while find_index < total_cubes_find && found_first == 0 {
                                                    if heidic_get_cube_active(find_index) == 1 {
                                                        if heidic_is_cube_selected(find_index) == 1 {
                                                            let cube_index_f: f32 = heidic_int_to_float(find_index);
                                                            selected_cube_index = cube_index_f + 2.0;
                                                            selected_cube_x = heidic_get_cube_x(find_index);
                                                            selected_cube_y = heidic_get_cube_y(find_index);
                                                            selected_cube_z = heidic_get_cube_z(find_index);
                                                            selected_cube_sx = heidic_get_cube_sx(find_index);
                                                            selected_cube_sy = heidic_get_cube_sy(find_index);
                                                            selected_cube_sz = heidic_get_cube_sz(find_index);
                                                            has_selection = 1;
                                                            found_first = 1;
                                                        }
                                                    }
                                                    find_index = find_index + 1;
                                                }
                                            }
                                        } else {
                                            // Regular click on selected cube: do nothing (keep selection)
                                        }
                                }
                            } else {
                                // Not selected: make clickable
                                // Check if Ctrl is pressed for multi-select
                                let ctrl_pressed: i32 = heidic_ctrl_down(window);
                                
                                // Not selected: show normally and make clickable
                                if heidic_imgui_selectable_str(cube_name) == 1 {
                                    // Clicked: select this cube
                                    if ctrl_pressed == 1 {
                                        // Ctrl+Click: add to selection (multi-select)
                                        heidic_add_to_selection(cube_index);
                                    } else {
                                        // Regular click: clear others and select only this one
                                        heidic_clear_selection();
                                        heidic_add_to_selection(cube_index);
                                    }
                                    
                                    // Update single selection state for gizmo (use this cube as primary)
                                    let cube_index_f: f32 = heidic_int_to_float(cube_index);
                                    selected_cube_index = cube_index_f + 2.0;
                                    selected_cube_x = heidic_get_cube_x(cube_index);
                                    selected_cube_y = heidic_get_cube_y(cube_index);
                                    selected_cube_z = heidic_get_cube_z(cube_index);
                                    selected_cube_sx = heidic_get_cube_sx(cube_index);
                                    selected_cube_sy = heidic_get_cube_sy(cube_index);
                                    selected_cube_sz = heidic_get_cube_sz(cube_index);
                                    has_selection = 1;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                            global_cube_display_index = global_cube_display_index + 1;
                        }
                    }
                    cube_index = cube_index + 1;
                }
                
                // Show mesh instances in outliner
                let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
                if mesh_instance_count > 0 {
                    heidic_imgui_separator();
                    heidic_imgui_text("Meshes:");
                    
                    let mesh_instance_index: i32 = 0;
                    while mesh_instance_index < mesh_instance_count {
                        if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                            heidic_imgui_push_id(mesh_instance_index + 10000);  // Offset to avoid conflicts
                            
                            let mesh_name: string = heidic_format_mesh_name(mesh_instance_index);
                            
                            // Make mesh name clickable to toggle selection
                            let is_mesh_selected: i32 = heidic_is_mesh_selected(mesh_instance_index);
                            
                            // Show selected meshes in tan/brown color, unselected in normal color
                            if is_mesh_selected == 1 {
                                // Selected: show in tan/brown color (0.8, 0.7, 0.5) and make clickable for deselection
                                if heidic_imgui_selectable_colored(mesh_name, 0.8, 0.7, 0.5, 1.0) == 1 {
                                    // Already selected: clicking again deselects it
                                    heidic_clear_mesh_selection();
                                    has_mesh_selection = 0;
                                    selected_mesh_instance_id = -1;
                                }
                            } else {
                                // Not selected: show normally and make clickable
                                if heidic_imgui_selectable_str(mesh_name) == 1 {
                                    // Not selected: clicking selects it
                                    heidic_clear_selection();
                                    heidic_clear_mesh_selection();
                                    heidic_add_mesh_to_selection(mesh_instance_index);
                                    
                                    // Update mesh selection state for gizmo
                                    selected_mesh_instance_id = mesh_instance_index;
                                    selected_mesh_x = heidic_get_mesh_instance_x(mesh_instance_index);
                                    selected_mesh_y = heidic_get_mesh_instance_y(mesh_instance_index);
                                    selected_mesh_z = heidic_get_mesh_instance_z(mesh_instance_index);
                                    has_mesh_selection = 1;
                                    has_selection = 0;  // Clear cube selection
                                    selected_cube_index = -1.0;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                        }
                        mesh_instance_index = mesh_instance_index + 1;
                    }
                }
                
                // Show wedges in outliner
                let wedge_total_count: i32 = heidic_get_wedge_total_count();
                if wedge_total_count > 0 {
                    heidic_imgui_separator();
                    heidic_imgui_text("Wedges:");
                    
                    let wedge_index: i32 = 0;
                    while wedge_index < wedge_total_count {
                        if heidic_get_wedge_active(wedge_index) == 1 {
                            heidic_imgui_push_id(wedge_index + 20000);  // Offset to avoid conflicts
                            
                            let wedge_name: string = heidic_format_wedge_name(wedge_index);
                            
                            // Make wedge name clickable to toggle selection
                            let is_wedge_selected: i32 = 0;
                            if has_wedge_selection == 1 && selected_wedge_index == wedge_index {
                                is_wedge_selected = 1;
                            }
                            
                            if is_wedge_selected == 1 {
                                // Selected: show in bold
                                heidic_imgui_text_bold(wedge_name);
                            } else {
                                // Not selected: make clickable
                                if heidic_imgui_selectable_str(wedge_name) == 1 {
                                    // Clicked: select this wedge
                                    heidic_clear_selection();
                                    heidic_clear_mesh_selection();
                                    selected_wedge_index = wedge_index;
                                    selected_wedge_x = heidic_get_wedge_x(wedge_index);
                                    selected_wedge_y = heidic_get_wedge_y(wedge_index);
                                    selected_wedge_z = heidic_get_wedge_z(wedge_index);
                                    selected_wedge_sx = heidic_get_wedge_sx(wedge_index);
                                    selected_wedge_sy = heidic_get_wedge_sy(wedge_index);
                                    selected_wedge_sz = heidic_get_wedge_sz(wedge_index);
                                    has_wedge_selection = 1;
                                    has_selection = 0;  // Clear cube selection
                                    has_mesh_selection = 0;  // Clear mesh selection
                                    selected_cube_index = -1.0;
                                    selected_mesh_instance_id = -1;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                        }
                        wedge_index = wedge_index + 1;
                    }
                }
                
                // Show lights in outliner
                let light_total_count: i32 = heidic_get_directional_light_total_count();
                if light_total_count > 0 {
                    heidic_imgui_separator();
                    heidic_imgui_text("Lights:");
                    
                    let light_index: i32 = 0;
                    while light_index < light_total_count {
                        if heidic_get_directional_light_active(light_index) == 1 {
                            heidic_imgui_push_id(light_index + 30000);  // Offset to avoid conflicts
                            
                            let light_name: string = heidic_format_light_name(light_index);
                            
                            // Make light name clickable to toggle selection
                            let is_light_selected: i32 = heidic_is_light_selected(light_index);
                            
                            // Show selected lights in tan/brown color, unselected in normal color
                            if is_light_selected == 1 {
                                // Selected: show in tan/brown color (0.8, 0.7, 0.5) and make clickable for deselection
                                if heidic_imgui_selectable_colored(light_name, 0.8, 0.7, 0.5, 1.0) == 1 {
                                    // Already selected: clicking again deselects it
                                    heidic_clear_light_selection();
                                    has_light_selection = 0;
                                    selected_light_id = -1;
                                }
                            } else {
                                // Not selected: show normally and make clickable
                                if heidic_imgui_selectable_str(light_name) == 1 {
                                    // Not selected: clicking selects it
                                    heidic_clear_selection();
                                    heidic_clear_mesh_selection();
                                    selected_wedge_index = -1;
                                    heidic_clear_light_selection();
                                    heidic_add_light_to_selection(light_index);
                                    selected_light_id = light_index;
                                    selected_light_x = heidic_get_directional_light_x(light_index);
                                    selected_light_y = heidic_get_directional_light_y(light_index);
                                    selected_light_z = heidic_get_directional_light_z(light_index);
                                    selected_light_dir_x = heidic_get_directional_light_dir_x(light_index);
                                    selected_light_dir_y = heidic_get_directional_light_dir_y(light_index);
                                    selected_light_dir_z = heidic_get_directional_light_dir_z(light_index);
                                    has_light_selection = 1;
                                    has_selection = 0;  // Clear cube selection
                                    has_mesh_selection = 0;  // Clear mesh selection
                                    has_wedge_selection = 0;  // Clear wedge selection
                                    selected_cube_index = -1.0;
                                    selected_mesh_instance_id = -1;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                        }
                        light_index = light_index + 1;
                    }
                }
                
                    heidic_imgui_end();
                }
            }
            
            // Wedge Rotation Position Panel (shows current position and coordinates)
            if build_mode == 1 {
                if heidic_imgui_begin("Wedge Rotation Position") == 1 {
                    // Calculate current rotation values based on position
                    let current_rot_x: f32 = 0.0;
                    let current_rot_y: f32 = 0.0;
                    let current_rot_z: f32 = 0.0;
                    
                    if wedge_preview_rotation == 0 {
                        current_rot_x = 270.0;
                        current_rot_y = 180.0;
                        current_rot_z = 90.0;
                    } else {
                        if wedge_preview_rotation == 1 {
                            current_rot_x = 180.0;
                            current_rot_y = 90.0;
                            current_rot_z = 270.0;
                        } else {
                            if wedge_preview_rotation == 2 {
                                current_rot_x = 90.0;
                                current_rot_y = 270.0;
                                current_rot_z = 180.0;
                            } else {
                                if wedge_preview_rotation == 3 {
                                    current_rot_x = 180.0;
                                    current_rot_y = 0.0;
                                    current_rot_z = 270.0;
                                } else {
                                    if wedge_preview_rotation == 4 {
                                        current_rot_x = 180.0;
                                        current_rot_y = 180.0;
                                        current_rot_z = 90.0;
                                    } else {
                                        if wedge_preview_rotation == 5 {
                                            current_rot_x = 180.0;
                                            current_rot_y = 90.0;
                                            current_rot_z = 90.0;
                                        } else {
                                            if wedge_preview_rotation == 6 {
                                                current_rot_x = 180.0;
                                                current_rot_y = 270.0;
                                                current_rot_z = 90.0;
                                            } else {
                                                if wedge_preview_rotation == 7 {
                                                    current_rot_x = 180.0;
                                                    current_rot_y = 0.0;
                                                    current_rot_z = 90.0;
                                                } else {
                                                    if wedge_preview_rotation == 8 {
                                                        current_rot_x = 180.0;
                                                        current_rot_y = 90.0;
                                                        current_rot_z = 180.0;
                                                    } else {
                                                        if wedge_preview_rotation == 9 {
                                                            current_rot_x = 90.0;
                                                            current_rot_y = 270.0;
                                                            current_rot_z = 270.0;
                                                        } else {
                                                            if wedge_preview_rotation == 10 {
                                                                current_rot_x = 90.0;
                                                                current_rot_y = 270.0;
                                                                current_rot_z = 90.0;
                                                            } else {
                                                                if wedge_preview_rotation == 11 {
                                                                    current_rot_x = 180.0;
                                                                    current_rot_y = 0.0;
                                                                    current_rot_z = 180.0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    heidic_imgui_text("Current Position:");
                    heidic_imgui_text("Index:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##PosIndex", heidic_int_to_float(wedge_preview_rotation));
                    heidic_imgui_text("(0-11)");
                    
                    heidic_imgui_separator();
                    
                    heidic_imgui_text("Rotation Coordinates:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##RotX", current_rot_x);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##RotY", current_rot_y);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##RotZ", current_rot_z);
                    
                    heidic_imgui_separator();
                    heidic_imgui_text("Use mouse wheel to cycle");
                    heidic_imgui_text("through 12 positions");
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window for Selected Wedge
            if has_wedge_selection == 1 && selected_wedge_index >= 0 {
                if heidic_imgui_begin("Properties") == 1 {
                    // Get current transform values
                    let current_x: f32 = heidic_get_wedge_x(selected_wedge_index);
                    let current_y: f32 = heidic_get_wedge_y(selected_wedge_index);
                    let current_z: f32 = heidic_get_wedge_z(selected_wedge_index);
                    let current_sx: f32 = heidic_get_wedge_sx(selected_wedge_index);
                    let current_sy: f32 = heidic_get_wedge_sy(selected_wedge_index);
                    let current_sz: f32 = heidic_get_wedge_sz(selected_wedge_index);
                    let current_rx: f32 = heidic_get_wedge_rx(selected_wedge_index);
                    let current_ry: f32 = heidic_get_wedge_ry(selected_wedge_index);
                    let current_rz: f32 = heidic_get_wedge_rz(selected_wedge_index);
                    
                    // Translation Inputs
                    heidic_imgui_text("Translation:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_x: f32 = heidic_imgui_input_float("##WedgeTransX", current_x, 1.0, 10.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_y: f32 = heidic_imgui_input_float("##WedgeTransY", current_y, 1.0, 10.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_z: f32 = heidic_imgui_input_float("##WedgeTransZ", current_z, 1.0, 10.0);
                    if new_x != current_x || new_y != current_y || new_z != current_z {
                        heidic_set_wedge_pos(selected_wedge_index, new_x, new_y, new_z);
                        selected_wedge_x = new_x;
                        selected_wedge_y = new_y;
                        selected_wedge_z = new_z;
                    }
                    
                    heidic_imgui_separator();
                    
                    // Scale Inputs
                    heidic_imgui_text("Scale:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_sx: f32 = heidic_imgui_input_float("##WedgeScaleX", current_sx, 0.1, 1.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_sy: f32 = heidic_imgui_input_float("##WedgeScaleY", current_sy, 0.1, 1.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_sz: f32 = heidic_imgui_input_float("##WedgeScaleZ", current_sz, 0.1, 1.0);
                    if new_sx < 0.01 {
                        new_sx = 0.01;
                    }
                    if new_sy < 0.01 {
                        new_sy = 0.01;
                    }
                    if new_sz < 0.01 {
                        new_sz = 0.01;
                    }
                    if new_sx != current_sx || new_sy != current_sy || new_sz != current_sz {
                        heidic_set_wedge_scale(selected_wedge_index, new_sx, new_sy, new_sz);
                    }
                    
                    heidic_imgui_separator();
                    
                    // Rotation - Slider and Input (both work independently)
                    heidic_imgui_text("Rotation:");
                    // X Rotation - Slider and Input
                    let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                    let new_rx_input: f32 = heidic_imgui_input_float("##WedgeRX", current_rx, 1.0, 10.0);
                    let new_rx: f32 = new_rx_slider;
                    if new_rx_input != current_rx {
                        new_rx = new_rx_input;
                    }
                    if new_rx != current_rx {
                        if new_rx < 0.0 {
                            new_rx = 0.0;
                        }
                        if new_rx > 360.0 {
                            new_rx = 360.0;
                        }
                        heidic_set_wedge_rotation(selected_wedge_index, new_rx, current_ry, current_rz);
                    }
                    
                    // Y Rotation - Slider and Input
                    let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                    let new_ry_input: f32 = heidic_imgui_input_float("##WedgeRY", current_ry, 1.0, 10.0);
                    let new_ry: f32 = new_ry_slider;
                    if new_ry_input != current_ry {
                        new_ry = new_ry_input;
                    }
                    if new_ry != current_ry {
                        if new_ry < 0.0 {
                            new_ry = 0.0;
                        }
                        if new_ry > 360.0 {
                            new_ry = 360.0;
                        }
                        heidic_set_wedge_rotation(selected_wedge_index, current_rx, new_ry, current_rz);
                    }
                    
                    // Z Rotation - Slider and Input
                    let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                    let new_rz_input: f32 = heidic_imgui_input_float("##WedgeRZ", current_rz, 1.0, 10.0);
                    let new_rz: f32 = new_rz_slider;
                    if new_rz_input != current_rz {
                        new_rz = new_rz_input;
                    }
                    if new_rz != current_rz {
                        if new_rz < 0.0 {
                            new_rz = 0.0;
                        }
                        if new_rz > 360.0 {
                            new_rz = 360.0;
                        }
                        heidic_set_wedge_rotation(selected_wedge_index, current_rx, current_ry, new_rz);
                    }
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window for Selected Light
            if has_light_selection == 1 && selected_light_id >= 0 {
                if heidic_imgui_begin("Properties") == 1 {
                    // Get current transform values
                    let current_x: f32 = heidic_get_directional_light_x(selected_light_id);
                    let current_y: f32 = heidic_get_directional_light_y(selected_light_id);
                    let current_z: f32 = heidic_get_directional_light_z(selected_light_id);
                    let current_dir_x: f32 = heidic_get_directional_light_dir_x(selected_light_id);
                    let current_dir_y: f32 = heidic_get_directional_light_dir_y(selected_light_id);
                    let current_dir_z: f32 = heidic_get_directional_light_dir_z(selected_light_id);
                    
                    // Position - Slider and Input (both work independently)
                    heidic_imgui_text("Position:");
                    // X Position - Slider and Input
                    let new_x_slider: f32 = heidic_imgui_slider_float("Position X", current_x, -1000.0, 1000.0);
                    let new_x_input: f32 = heidic_imgui_input_float("##LightPosX", current_x, 1.0, 10.0);
                    let new_x: f32 = new_x_slider;
                    if new_x_input != current_x {
                        new_x = new_x_input;
                    }
                    if new_x != current_x {
                        heidic_set_directional_light_pos(selected_light_id, new_x, current_y, current_z);
                        selected_light_x = new_x;
                    }
                    
                    // Y Position - Slider and Input
                    let new_y_slider: f32 = heidic_imgui_slider_float("Position Y", current_y, -1000.0, 1000.0);
                    let new_y_input: f32 = heidic_imgui_input_float("##LightPosY", current_y, 1.0, 10.0);
                    let new_y: f32 = new_y_slider;
                    if new_y_input != current_y {
                        new_y = new_y_input;
                    }
                    if new_y != current_y {
                        heidic_set_directional_light_pos(selected_light_id, current_x, new_y, current_z);
                        selected_light_y = new_y;
                    }
                    
                    // Z Position - Slider and Input
                    let new_z_slider: f32 = heidic_imgui_slider_float("Position Z", current_z, -1000.0, 1000.0);
                    let new_z_input: f32 = heidic_imgui_input_float("##LightPosZ", current_z, 1.0, 10.0);
                    let new_z: f32 = new_z_slider;
                    if new_z_input != current_z {
                        new_z = new_z_input;
                    }
                    if new_z != current_z {
                        heidic_set_directional_light_pos(selected_light_id, current_x, current_y, new_z);
                        selected_light_z = new_z;
                    }
                    
                    heidic_imgui_separator();
                    
                    // Direction - Slider and Input (both work independently)
                    heidic_imgui_text("Direction:");
                    // X Direction - Slider and Input
                    let new_dir_x_slider: f32 = heidic_imgui_slider_float("Direction X", current_dir_x, -1.0, 1.0);
                    let new_dir_x_input: f32 = heidic_imgui_input_float("##LightDirX", current_dir_x, 0.01, 0.1);
                    let new_dir_x: f32 = new_dir_x_slider;
                    if new_dir_x_input != current_dir_x {
                        new_dir_x = new_dir_x_input;
                    }
                    if new_dir_x != current_dir_x {
                        heidic_set_directional_light_dir(selected_light_id, new_dir_x, current_dir_y, current_dir_z);
                        selected_light_dir_x = new_dir_x;
                    }
                    
                    // Y Direction - Slider and Input
                    let new_dir_y_slider: f32 = heidic_imgui_slider_float("Direction Y", current_dir_y, -1.0, 1.0);
                    let new_dir_y_input: f32 = heidic_imgui_input_float("##LightDirY", current_dir_y, 0.01, 0.1);
                    let new_dir_y: f32 = new_dir_y_slider;
                    if new_dir_y_input != current_dir_y {
                        new_dir_y = new_dir_y_input;
                    }
                    if new_dir_y != current_dir_y {
                        heidic_set_directional_light_dir(selected_light_id, current_dir_x, new_dir_y, current_dir_z);
                        selected_light_dir_y = new_dir_y;
                    }
                    
                    // Z Direction - Slider and Input
                    let new_dir_z_slider: f32 = heidic_imgui_slider_float("Direction Z", current_dir_z, -1.0, 1.0);
                    let new_dir_z_input: f32 = heidic_imgui_input_float("##LightDirZ", current_dir_z, 0.01, 0.1);
                    let new_dir_z: f32 = new_dir_z_slider;
                    if new_dir_z_input != current_dir_z {
                        new_dir_z = new_dir_z_input;
                    }
                    if new_dir_z != current_dir_z {
                        heidic_set_directional_light_dir(selected_light_id, current_dir_x, current_dir_y, new_dir_z);
                        selected_light_dir_z = new_dir_z;
                    }
                    
                    heidic_imgui_separator();
                    
                    // Color Controls
                    heidic_imgui_text("Color:");
                    let current_r: f32 = heidic_get_directional_light_r(selected_light_id);
                    let current_g: f32 = heidic_get_directional_light_g(selected_light_id);
                    let current_b: f32 = heidic_get_directional_light_b(selected_light_id);
                    
                    // R Color - Slider and Input
                    let new_r_slider: f32 = heidic_imgui_slider_float("Color R", current_r, 0.0, 1.0);
                    let new_r_input: f32 = heidic_imgui_input_float("##LightColorR", current_r, 0.01, 0.1);
                    let new_r: f32 = new_r_slider;
                    if new_r_input != current_r {
                        new_r = new_r_input;
                    }
                    if new_r != current_r {
                        heidic_set_directional_light_color(selected_light_id, new_r, current_g, current_b);
                    }
                    
                    // G Color - Slider and Input
                    let new_g_slider: f32 = heidic_imgui_slider_float("Color G", current_g, 0.0, 1.0);
                    let new_g_input: f32 = heidic_imgui_input_float("##LightColorG", current_g, 0.01, 0.1);
                    let new_g: f32 = new_g_slider;
                    if new_g_input != current_g {
                        new_g = new_g_input;
                    }
                    if new_g != current_g {
                        heidic_set_directional_light_color(selected_light_id, current_r, new_g, current_b);
                    }
                    
                    // B Color - Slider and Input
                    let new_b_slider: f32 = heidic_imgui_slider_float("Color B", current_b, 0.0, 1.0);
                    let new_b_input: f32 = heidic_imgui_input_float("##LightColorB", current_b, 0.01, 0.1);
                    let new_b: f32 = new_b_slider;
                    if new_b_input != current_b {
                        new_b = new_b_input;
                    }
                    if new_b != current_b {
                        heidic_set_directional_light_color(selected_light_id, current_r, current_g, new_b);
                    }
                    
                    heidic_imgui_separator();
                    
                    // Intensity Control
                    heidic_imgui_text("Intensity:");
                    let current_intensity: f32 = heidic_get_directional_light_intensity(selected_light_id);
                    let new_intensity_slider: f32 = heidic_imgui_slider_float("Intensity", current_intensity, 0.0, 5.0);
                    let new_intensity_input: f32 = heidic_imgui_input_float("##LightIntensity", current_intensity, 0.1, 1.0);
                    let new_intensity: f32 = new_intensity_slider;
                    if new_intensity_input != current_intensity {
                        new_intensity = new_intensity_input;
                    }
                    if new_intensity != current_intensity {
                        if new_intensity < 0.0 {
                            new_intensity = 0.0;
                        }
                        heidic_set_directional_light_intensity(selected_light_id, new_intensity);
                    }
                    
                    // Range Control (for point/spot lights)
                    // Note: Always shown - directional lights will ignore range, point/spot lights use it
                    // Workaround: Can't use heidic_get_light_type() because "type" is a reserved keyword in HEIDIC
                    heidic_imgui_separator();
                    heidic_imgui_text("Range:");
                    let current_range: f32 = heidic_get_light_range(selected_light_id);
                    let new_range_slider: f32 = heidic_imgui_slider_float("Range", current_range, 0.0, 5000.0);
                    let new_range_input: f32 = heidic_imgui_input_float("##LightRange", current_range, 10.0, 100.0);
                    let new_range: f32 = new_range_slider;
                    if new_range_input != current_range {
                        new_range = new_range_input;
                    }
                    if new_range != current_range {
                        if new_range < 0.0 {
                            new_range = 0.0;
                        }
                        heidic_set_light_range(selected_light_id, new_range);
                    }
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window
            if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
                if heidic_imgui_begin("Properties") == 1 {
                    // Get current transform values
                    let current_x: f32 = heidic_get_mesh_instance_x(selected_mesh_instance_id);
                    let current_y: f32 = heidic_get_mesh_instance_y(selected_mesh_instance_id);
                    let current_z: f32 = heidic_get_mesh_instance_z(selected_mesh_instance_id);
                    let current_sx: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
                    let current_sy: f32 = heidic_get_mesh_instance_sy(selected_mesh_instance_id);
                    let current_sz: f32 = heidic_get_mesh_instance_sz(selected_mesh_instance_id);
                    let current_rx: f32 = heidic_get_mesh_instance_rx(selected_mesh_instance_id);
                    let current_ry: f32 = heidic_get_mesh_instance_ry(selected_mesh_instance_id);
                    let current_rz: f32 = heidic_get_mesh_instance_rz(selected_mesh_instance_id);
                    
                    // Translation Inputs
                    heidic_imgui_text("Translation:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_x: f32 = heidic_imgui_input_float("##TransX", current_x, 1.0, 10.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_y: f32 = heidic_imgui_input_float("##TransY", current_y, 1.0, 10.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_z: f32 = heidic_imgui_input_float("##TransZ", current_z, 1.0, 10.0);
                    if new_x != current_x || new_y != current_y || new_z != current_z {
                        heidic_set_mesh_instance_pos(selected_mesh_instance_id, new_x, new_y, new_z);
                        // Update cached position values so gizmo updates immediately
                        selected_mesh_x = new_x;
                        selected_mesh_y = new_y;
                        selected_mesh_z = new_z;
                    }
                    
                    heidic_imgui_separator();
                    
                    // Scale Inputs
                    heidic_imgui_text("Scale:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_sx: f32 = heidic_imgui_input_float("##ScaleX", current_sx, 0.1, 1.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_sy: f32 = heidic_imgui_input_float("##ScaleY", current_sy, 0.1, 1.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_sz: f32 = heidic_imgui_input_float("##ScaleZ", current_sz, 0.1, 1.0);
                    // Clamp scale to positive values
                    if new_sx < 0.01 {
                        new_sx = 0.01;
                    }
                    if new_sy < 0.01 {
                        new_sy = 0.01;
                    }
                    if new_sz < 0.01 {
                        new_sz = 0.01;
                    }
                    if new_sx != current_sx || new_sy != current_sy || new_sz != current_sz {
                        heidic_set_mesh_instance_scale(selected_mesh_instance_id, new_sx, new_sy, new_sz);
                    }
                    
                    heidic_imgui_separator();
                    
                    // Rotation - Slider and Input (both work independently)
                    heidic_imgui_text("Rotation:");
                    // X Rotation - Slider and Input (both work independently)
                    let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                    let new_rx_input: f32 = heidic_imgui_input_float("##RX", current_rx, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_rx: f32 = new_rx_slider;
                    if new_rx_input != current_rx {
                        new_rx = new_rx_input;
                    }
                    if new_rx != current_rx {
                        // Clamp to 0-360 range
                        if new_rx < 0.0 {
                            new_rx = 0.0;
                        }
                        if new_rx > 360.0 {
                            new_rx = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, new_rx, current_ry, current_rz);
                    }
                    
                    // Y Rotation - Slider and Input (both work independently)
                    let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                    let new_ry_input: f32 = heidic_imgui_input_float("##RY", current_ry, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_ry: f32 = new_ry_slider;
                    if new_ry_input != current_ry {
                        new_ry = new_ry_input;
                    }
                    if new_ry != current_ry {
                        // Clamp to 0-360 range
                        if new_ry < 0.0 {
                            new_ry = 0.0;
                        }
                        if new_ry > 360.0 {
                            new_ry = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, current_rx, new_ry, current_rz);
                    }
                    
                    // Z Rotation - Slider and Input (both work independently)
                    let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                    let new_rz_input: f32 = heidic_imgui_input_float("##RZ", current_rz, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_rz: f32 = new_rz_slider;
                    if new_rz_input != current_rz {
                        new_rz = new_rz_input;
                    }
                    if new_rz != current_rz {
                        // Clamp to 0-360 range
                        if new_rz < 0.0 {
                            new_rz = 0.0;
                        }
                        if new_rz > 360.0 {
                            new_rz = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, current_rx, current_ry, new_rz);
                    }
                    
                    heidic_imgui_separator();
                    
                    // HEIDIC Function Input
                    heidic_imgui_text("Heidic Function:");
                    let function_input_result: i32 = heidic_imgui_input_text_mesh_heidic_function(selected_mesh_instance_id);
                    if function_input_result == 1 {
                        // Enter was pressed, function name was applied
                        print("HEIDIC function applied successfully\n");
                    }
                    heidic_imgui_same_line();
                    if heidic_imgui_button("Apply") == 1 {
                        let function_name: string = heidic_get_mesh_heidic_function_input_buffer(selected_mesh_instance_id);
                        if function_name != "" {
                            let result: i32 = heidic_set_mesh_instance_heidic_function(selected_mesh_instance_id, function_name);
                            if result == 1 {
                                print("HEIDIC function applied successfully: ");
                                print(function_name);
                                print("\n");
                            } else {
                                print("Failed to apply HEIDIC function: ");
                                print(function_name);
                                print("\n");
                            }
                        }
                    }
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window for Selected Cube
            if has_selection == 1 && selected_cube_index >= 2.0 {
                let cube_storage_index: i32 = heidic_float_to_int(selected_cube_index - 2.0);
                if heidic_get_cube_active(cube_storage_index) == 1 {
                if heidic_imgui_begin("Properties") == 1 {
                        // Get current transform values
                        let current_x: f32 = heidic_get_cube_x(cube_storage_index);
                        let current_y: f32 = heidic_get_cube_y(cube_storage_index);
                        let current_z: f32 = heidic_get_cube_z(cube_storage_index);
                        let current_sx: f32 = heidic_get_cube_sx(cube_storage_index);
                        let current_sy: f32 = heidic_get_cube_sy(cube_storage_index);
                        let current_sz: f32 = heidic_get_cube_sz(cube_storage_index);
                        let current_rx: f32 = heidic_get_cube_rx(cube_storage_index);
                        let current_ry: f32 = heidic_get_cube_ry(cube_storage_index);
                        let current_rz: f32 = heidic_get_cube_rz(cube_storage_index);
                        
                        // Translation Inputs
                        heidic_imgui_text("Translation:");
                        heidic_imgui_text("X:");
                        heidic_imgui_same_line();
                        let new_x: f32 = heidic_imgui_input_float("##CubeTransX", current_x, 1.0, 10.0);
                        heidic_imgui_text("Y:");
                        heidic_imgui_same_line();
                        let new_y: f32 = heidic_imgui_input_float("##CubeTransY", current_y, 1.0, 10.0);
                        heidic_imgui_text("Z:");
                        heidic_imgui_same_line();
                        let new_z: f32 = heidic_imgui_input_float("##CubeTransZ", current_z, 1.0, 10.0);
                        if new_x != current_x || new_y != current_y || new_z != current_z {
                            heidic_set_cube_pos(cube_storage_index, new_x, new_y, new_z);
                        }
                        
                        heidic_imgui_separator();
                        
                        // Scale Inputs
                        heidic_imgui_text("Scale:");
                        heidic_imgui_text("X:");
                        heidic_imgui_same_line();
                        let new_sx: f32 = heidic_imgui_input_float("##CubeScaleX", current_sx, 0.1, 1.0);
                        heidic_imgui_text("Y:");
                        heidic_imgui_same_line();
                        let new_sy: f32 = heidic_imgui_input_float("##CubeScaleY", current_sy, 0.1, 1.0);
                        heidic_imgui_text("Z:");
                        heidic_imgui_same_line();
                        let new_sz: f32 = heidic_imgui_input_float("##CubeScaleZ", current_sz, 0.1, 1.0);
                        // Clamp scale to positive values
                        if new_sx < 0.01 {
                            new_sx = 0.01;
                        }
                        if new_sy < 0.01 {
                            new_sy = 0.01;
                        }
                        if new_sz < 0.01 {
                            new_sz = 0.01;
                        }
                        if new_sx != current_sx || new_sy != current_sy || new_sz != current_sz {
                            heidic_set_cube_scale(cube_storage_index, new_sx, new_sy, new_sz);
                        }
                        
                        heidic_imgui_separator();
                        
                        // Rotation - Slider and Input (both work independently)
                        heidic_imgui_text("Rotation:");
                        // X Rotation - Slider and Input (both work independently)
                        let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                        let new_rx_input: f32 = heidic_imgui_input_float("##CubeRX", current_rx, 1.0, 10.0);
                        // Use input value if it changed, otherwise use slider value
                        let new_rx: f32 = new_rx_slider;
                        if new_rx_input != current_rx {
                            new_rx = new_rx_input;
                        }
                        if new_rx != current_rx {
                            // Clamp to 0-360 range
                            if new_rx < 0.0 {
                                new_rx = 0.0;
                            }
                            if new_rx > 360.0 {
                                new_rx = 360.0;
                            }
                            heidic_set_cube_rotation(cube_storage_index, new_rx, current_ry, current_rz);
                        }
                        
                        // Y Rotation - Slider and Input (both work independently)
                        let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                        let new_ry_input: f32 = heidic_imgui_input_float("##CubeRY", current_ry, 1.0, 10.0);
                        // Use input value if it changed, otherwise use slider value
                        let new_ry: f32 = new_ry_slider;
                        if new_ry_input != current_ry {
                            new_ry = new_ry_input;
                        }
                        if new_ry != current_ry {
                            // Clamp to 0-360 range
                            if new_ry < 0.0 {
                                new_ry = 0.0;
                            }
                            if new_ry > 360.0 {
                                new_ry = 360.0;
                            }
                            heidic_set_cube_rotation(cube_storage_index, current_rx, new_ry, current_rz);
                        }
                        
                        // Z Rotation - Slider and Input (both work independently)
                        let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                        let new_rz_input: f32 = heidic_imgui_input_float("##CubeRZ", current_rz, 1.0, 10.0);
                        // Use input value if it changed, otherwise use slider value
                        let new_rz: f32 = new_rz_slider;
                        if new_rz_input != current_rz {
                            new_rz = new_rz_input;
                        }
                        if new_rz != current_rz {
                            // Clamp to 0-360 range
                            if new_rz < 0.0 {
                                new_rz = 0.0;
                            }
                            if new_rz > 360.0 {
                                new_rz = 360.0;
                            }
                            heidic_set_cube_rotation(cube_storage_index, current_rx, current_ry, new_rz);
                        }
                        
                        heidic_imgui_end();
                    }
                }
            }
            
            // Texture Swatches Window
            // print("[HEIDIC DEBUG] About to begin Texture Swatches window\n");  // Debug: uncomment when needed
            // Texture Swatches window
            if show_texture_swatches_window == 1 {
                if heidic_imgui_begin("Texture Swatches") == 0 {
                    // Window was closed (X button clicked)
                    show_texture_swatches_window = 0;
                } else {
                // print("[HEIDIC DEBUG] Inside Texture Swatches window\n");  // Debug: uncomment when needed
                // Load texture list on first frame
                heidic_load_texture_list();
                // print("[HEIDIC DEBUG] After heidic_load_texture_list()\n");  // Debug: uncomment when needed
                
                let texture_count: i32 = heidic_get_texture_count();
                // print("[HEIDIC DEBUG] Got texture_count, starting loop\n");  // Debug: uncomment when needed
                
                // Display textures in a grid as image previews
                let texture_index: i32 = 0;
                let items_per_row: i32 = 6;  // 6 textures per row
                let current_col: i32 = 0;
                let swatch_size: f32 = 64.0;  // 64x64 pixel previews
                
                // print("[HEIDIC DEBUG] Starting texture loop\n");  // Debug: uncomment when needed
                while texture_index < texture_count {
                    // if texture_index == 0 {
                    //     print("[HEIDIC DEBUG] First texture iteration\n");  // Debug: uncomment when needed
                    // }
                    // if texture_index == 10 {
                    //     print("[HEIDIC DEBUG] 10th texture iteration\n");  // Debug: uncomment when needed
                    // }
                    // if texture_index == 20 {
                    //     print("[HEIDIC DEBUG] 20th texture iteration\n");  // Debug: uncomment when needed
                    // }
                    
                    let texture_name: string = heidic_get_texture_name(texture_index);
                    // print("[HEIDIC DEBUG] Got texture_name, about to get preview ID\n");  // Debug: uncomment when needed
                    
                    // Load texture preview and get ID
                    let texture_id: i64 = heidic_get_texture_preview_id(texture_name);
                    // print("[HEIDIC DEBUG] Got texture_id\n");  // Debug: uncomment when needed
                    
                    // Create unique ID for button
                    heidic_imgui_push_id(texture_index);
                    
                    // Check if this texture is selected (get fresh value each iteration)
                    let selected_texture: string = heidic_get_selected_texture();
                    let is_selected: i32 = 0;
                    if selected_texture == texture_name {
                        is_selected = 1;
                    }
                    
                    // Display as image button
                    if texture_id != 0 {
                        // Use tint color to indicate selection (yellow tint if selected)
                        let tint_r: f32 = 1.0;
                        let tint_g: f32 = 1.0;
                        let tint_b: f32 = 1.0;
                        let tint_a: f32 = 1.0;
                        if is_selected == 1 {
                            tint_r = 1.0;
                            tint_g = 1.0;
                            tint_b = 0.5;  // Yellow tint for selected
                        }
                        
                        // Create unique button ID using texture index
                        // Use texture_name as part of ID to ensure uniqueness
                        let button_id: string = texture_name;
                        // Use ImageButton with tint
                        if heidic_imgui_image_button(button_id, texture_id, swatch_size, swatch_size, tint_r, tint_g, tint_b, tint_a) == 1 {
                            // Clicked: select this texture
                            heidic_set_selected_texture(texture_name);
                        }
                    } else {
                        // Fallback to text if texture failed to load
                        heidic_imgui_text_str_wrapper(texture_name);
                    }
                    
                    heidic_imgui_pop_id();
                    
                    // Same line for grid layout
                    current_col = current_col + 1;
                    if current_col < items_per_row {
                        heidic_imgui_same_line();
                    } else {
                        current_col = 0;
                    }
                    
                    texture_index = texture_index + 1;
                }
                
                    heidic_imgui_end();
                }
            }
            
            // UV Editor Window
            if show_uv_editor_window == 1 {
                if heidic_imgui_begin("UV Editor") == 0 {
                    // Window was closed (X button clicked)
                    show_uv_editor_window = 0;
                } else {
                let mesh_count: i32 = heidic_get_mesh_count();
                if mesh_count > 0 {
                    let mesh_index: i32 = 0;
                    while mesh_index < mesh_count {
                        let mesh_id: i32 = heidic_get_mesh_id(mesh_index);
                        heidic_imgui_text("Mesh ID: ");
                        heidic_imgui_same_line();
                        heidic_imgui_text_int(mesh_id);
                        
                        heidic_imgui_text("Tip: Only materials with 'Diffuse' textures are rendered.");
                        heidic_imgui_text("Bright shells = will render, Dim shells = skipped (non-diffuse)");
                        
                        // Draw UV layout - uses ImGui's content region automatically
                        heidic_draw_uv_layout(mesh_id);
                        
                        heidic_imgui_separator();
                        mesh_index = mesh_index + 1;
                    }
                } else {
                    heidic_imgui_text("No meshes loaded");
                }
                
                    heidic_imgui_end();
                }
            }
            
            // Performance Info Window
            if show_performance_info_window == 1 {
                if heidic_imgui_begin("Performance Info") == 0 {
                    // Window was closed (X button clicked)
                    show_performance_info_window = 0;
                } else {
                let fps: f32 = heidic_get_fps();
                let frame_time: f32 = heidic_get_frame_time();
                let polygon_count: i32 = heidic_get_total_polygon_count();
                let texture_memory: f32 = heidic_get_texture_memory_mb();
                
                heidic_imgui_text("FPS: ");
                heidic_imgui_same_line();
                heidic_imgui_text_float("", fps);
                
                heidic_imgui_text("Frame Time: ");
                heidic_imgui_same_line();
                heidic_imgui_text_float("", frame_time);
                heidic_imgui_same_line();
                heidic_imgui_text(" ms");
                
                heidic_imgui_separator();
                
                heidic_imgui_text("Polygons: ");
                heidic_imgui_same_line();
                heidic_imgui_text_int(polygon_count);
                
                heidic_imgui_text("Texture Memory: ");
                heidic_imgui_same_line();
                heidic_imgui_text_float("", texture_memory);
                heidic_imgui_same_line();
                heidic_imgui_text(" MB");
                
                    heidic_imgui_end();
                }
            }
        }
        // print("[HEIDIC DEBUG] After all ImGui windows\n");  // Debug: uncomment when needed
        
        // Player cube is not selectable, so no position syncing needed
        // print("[HEIDIC DEBUG] Before ground detection section\n");  // Debug: uncomment when needed
        
        // Ground detection for player
        let ground_check_distance: f32 = 200.0; // 2 meters down
        // print("[HEIDIC DEBUG] Before ground detection\n");  // Debug: uncomment when needed
        is_grounded = heidic_raycast_ground_hit(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
        // print("[HEIDIC DEBUG] After ground detection\n");  // Debug: uncomment when needed
        
        // Visual feedback: Draw ray from player to ground
        if is_grounded == 1 {
            let ground_hit: Vec3 = heidic_raycast_ground_hit_point(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
            // Draw green line from player to ground (grounded)
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_hit.x, ground_hit.y, ground_hit.z, 0.0, 1.0, 0.0);
        } else {
            // Draw red line straight down (not grounded)
            let ground_check_end: Vec3 = heidic_vec3(player_pos.x, player_pos.y - ground_check_distance, player_pos.z);
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_check_end.x, ground_check_end.y, ground_check_end.z, 1.0, 0.0, 0.0);
        }
        // print("[HEIDIC DEBUG] After drawing ground lines\n");  // Debug: uncomment when needed
        
        // Debug Panel and Outliner removed - will be reimplemented from scratch
        
        // print("[HEIDIC DEBUG] Before calling heidic_end_frame()\n");  // Debug: uncomment when needed
        heidic_end_frame();
        // print("[HEIDIC DEBUG] After calling heidic_end_frame()\n");  // Debug: uncomment when needed
        
        // Save ImGui layout each frame (will save on last frame before window closes)
        // Note: Function accepts empty string for default path
        heidic_imgui_save_layout(default_ini_path_load);
    }
}

