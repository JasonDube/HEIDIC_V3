# EDEN Engine vs HEIDIC Language

## The Distinction

**HEIDIC** and **EDEN Engine** are two tightly-coupled but distinct parts of the same project:

### HEIDIC Language
- **What it is**: A custom programming language that transpiles to C++
- **Location**: `src/` (Rust compiler: lexer, parser, type checker, codegen)
- **Purpose**: Provides a clean, game-focused syntax for writing engine code
- **Output**: Generates C++ code that uses EDEN Engine APIs

### EDEN Engine
- **What it is**: The runtime game engine and standard library
- **Location**: `vulkan/`, `stdlib/`, `H_SCRIBE/`
- **Purpose**: Provides the actual game engine functionality (rendering, ECS, hot-reload, etc.)
- **Runtime**: C++ code that executes when you run your game

---

## The Relationship

```
┌─────────────────┐
│   HEIDIC Code   │  ← You write this (.hd files)
│  (your game)    │
└────────┬────────┘
         │
         │ HEIDIC Compiler (Rust)
         │ transpiles to...
         ▼
┌─────────────────┐
│  Generated C++  │  ← Auto-generated
│     Code        │
└────────┬────────┘
         │
         │ Uses/links to...
         ▼
┌─────────────────┐
│  EDEN Engine    │  ← The runtime engine
│  (C++ Runtime)  │
│  - Vulkan       │
│  - ECS          │
│  - CONTINUUM    │
│  - stdlib/      │
└─────────────────┘
```

---

## What Each Provides

### HEIDIC Language (`src/`)
- **Syntax**: `fn`, `let`, `component`, `system`, `@hot`, etc.
- **Type System**: `i32`, `f32`, `Vec3`, `Mat4`, etc.
- **Language Features**: Type inference, ECS queries, SOA layouts
- **Compilation**: Transpiles HEIDIC → C++

### EDEN Engine (`vulkan/`, `stdlib/`)
- **Rendering**: Vulkan renderer (`eden_vulkan_helpers.cpp`)
- **ECS**: Entity storage system (`stdlib/entity_storage.h`)
- **CONTINUUM**: Hot-reload runtime (system DLL swapping, shader reloading, component migrations)
- **Standard Library**: 
  - `stdlib/vulkan.h` - Vulkan types/functions
  - `stdlib/glfw.h` - GLFW windowing
  - `stdlib/math.h` - GLM math types
  - `stdlib/imgui.h` - ImGui integration
  - `stdlib/entity_storage.h` - ECS storage
- **Editor**: H_SCRIBE (`H_SCRIBE/main.py`)

---

## Example: How They Work Together

### HEIDIC Code (You Write)
```heidic
@hot
component Position {
    x: f32,
    y: f32,
    z: f32,
}

fn main(): void {
    let window = glfwCreateWindow(800, 600, "Game");
    heidic_init_renderer_balls(window);
}
```

### Generated C++ (Auto-Generated by HEIDIC Compiler)
```cpp
// Generated from HEIDIC
struct Position {
    float x;
    float y;
    float z;
};

int heidic_main() {
    GLFWwindow* window = glfwCreateWindow(800, 600, "Game");
    heidic_init_renderer_balls(window);  // ← Calls EDEN Engine function
    return 0;
}
```

### EDEN Engine Runtime (Pre-Built)
```cpp
// In vulkan/eden_vulkan_helpers.cpp (part of EDEN Engine)
void heidic_init_renderer_balls(GLFWwindow* window) {
    // Actual Vulkan initialization code
    // Uses EDEN Engine's Vulkan renderer
}
```

---

## Why They're Separated (But Together)

### Conceptual Separation:
- **HEIDIC** = The **language/compiler** (syntax, type system, code generation)
- **EDEN Engine** = The **runtime/engine** (Vulkan, ECS, hot-reload, APIs)

### Practical Coupling:
- HEIDIC is **designed specifically** for EDEN Engine
- Generated C++ code **depends on** EDEN Engine's standard library
- EDEN Engine provides the APIs that HEIDIC code uses
- They're **intentionally tightly integrated** for optimal workflow

---

## Analogies

### Unity
- **HEIDIC** ≈ C# language
- **EDEN Engine** ≈ Unity Engine runtime
- Unity C# code compiles to IL that runs on Unity's engine runtime

### Unreal
- **HEIDIC** ≈ Blueprints/UnrealScript (the language)
- **EDEN Engine** ≈ Unreal Engine (the runtime)
- Blueprint code executes using Unreal Engine's C++ backend

### Godot
- **HEIDIC** ≈ GDScript
- **EDEN Engine** ≈ Godot Engine core
- GDScript code runs on Godot's engine runtime

---

## File Structure Breakdown

```
HEIDIC/
├── src/                    ← HEIDIC Language (Compiler)
│   ├── lexer.rs           (Parse HEIDIC syntax)
│   ├── parser.rs          (Build AST)
│   ├── type_checker.rs    (Type checking)
│   └── codegen.rs         (Generate C++ from HEIDIC)
│
├── stdlib/                 ← EDEN Engine Standard Library
│   ├── vulkan.h           (Vulkan API bindings)
│   ├── glfw.h             (GLFW windowing)
│   ├── entity_storage.h   (ECS storage)
│   └── math.h             (Math types)
│
├── vulkan/                 ← EDEN Engine Runtime
│   ├── eden_vulkan_helpers.cpp  (Actual Vulkan code)
│   └── eden_vulkan_helpers.h
│
└── H_SCRIBE/              ← EDEN Engine Tooling
    └── main.py            (Editor for HEIDIC)
```

---

## Key Takeaway

**HEIDIC** is the **language you write**.
**EDEN Engine** is the **engine that runs it**.

They're two sides of the same coin:
- You write **HEIDIC code** (`.hd` files)
- HEIDIC compiler generates **C++ code**
- That C++ code uses **EDEN Engine APIs** to actually render, manage entities, etc.
- **EDEN Engine** provides CONTINUUM (hot-reload), ECS, Vulkan renderer, etc.

Together, they form a complete game development system:
- **HEIDIC** = The pleasant interface
- **EDEN Engine** = The powerful engine underneath

